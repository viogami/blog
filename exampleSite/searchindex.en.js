var relearn_searchindex = [
  {
    "breadcrumb": "Purple Pulpo",
    "content": "VioGo–不止聊天的奇妙bot 纯go编写的机器人业务后端，bot取名为 Vio ，qq机器人的实现基于gocq提供的api，基于gocq的上报事件调用转发外部讯息并返回。 可以完成基于chatgpt聊天任务，以及一些简单的指令响应。 如果你有想法和意见请提issue！这对我和bot都很重要！ 欢迎qq加群讨论：340961300\np5r预告信生成器API 预告信生成器国外作者原版：https://skyventuree.github.io/p5cc/index.html.我制作了api版本供生产或娱乐使用。网页版有汉化版但最近网站貌似挂了，如果反响好我就自己部署一个网页版公开下。\n基于gocq的qqbot搭建 你至少需要启动三个服务 qsign服务器 go-cqhttp 你自己的机器人后端 gocq只需要启动项目即可，不需要配置域名，qsign和你的后端都需要配置域名 为了可以实现双向通信，你的后端需要实现websocket的通信。\n基于pyautogui的自动化程序 主要使用pyautogui的库实现，以及使用gooey库制作了GUI。 详细请访问我的github项目页面\nFavAni–从0开始的web开发日志 演示DEMO地址 技术栈：gin+gorm+mysql+jwt+redis+grpc+pytorch+vue3+vite+tailwind\n【PYQT】赛马娘抽卡模拟器-基于Bwiki的抽卡模拟(上) 之前课程设计做过，当时搞得还是挺烂的，PYQT挺好用的，现在基于之前的改进，使得功能更加符合正常的抽卡模拟器需求，同时添加连接数据库。\n【PYQT】赛马娘抽卡模拟器-基于Bwiki的抽卡模拟(下) 前言 本贴将之前没有连接数据库的抽卡模拟器全部完善，最终已经放在了Github上",
    "description": "VioGo–不止聊天的奇妙bot 纯go编写的机器人业务后端，bot取名为 Vio ，qq机器人的实现基于gocq提供的api，基于gocq的上报事件调用转发外部讯息并返回。 可以完成基于chatgpt聊天任务，以及一些简单的指令响应。 如果你有想法和意见请提issue！这对我和bot都很重要！ 欢迎qq加群讨论：340961300\np5r预告信生成器API 预告信生成器国外作者原版：https://skyventuree.github.io/p5cc/index.html.我制作了api版本供生产或娱乐使用。网页版有汉化版但最近网站貌似挂了，如果反响好我就自己部署一个网页版公开下。\n基于gocq的qqbot搭建 你至少需要启动三个服务 qsign服务器 go-cqhttp 你自己的机器人后端 gocq只需要启动项目即可，不需要配置域名，qsign和你的后端都需要配置域名 为了可以实现双向通信，你的后端需要实现websocket的通信。\n基于pyautogui的自动化程序 主要使用pyautogui的库实现，以及使用gooey库制作了GUI。 详细请访问我的github项目页面",
    "tags": [],
    "title": "Project",
    "uri": "/hugo-theme-relearn/exampleSite/project/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Captain's Log",
    "content": "Launch Day Captain’s Log, 0120 hours\n“No mission too saucy for us!”\n– Captain’s official decree\nIt seems we accidentally loaded a crate of rubber chickens instead of emergency food rations, but the crew is already brainstorming new dance routines with them. Meanwhile, our quartermaster replaced the lifebuoys with giant doughnuts for a “themed” departure—perfect for dunking our morale into sugary bliss.\nStatus Reason for voyage: A midnight run to deliver top-secret cargo (pasta flour and extra marinara). Crew status: Eager to set sail Full of energy (and possibly leftover breadsticks) Early Observations The moonlit sky casts The Purple Pulpo in a mysterious glow. Rumor has it, our octopus figurehead twitched its wooden tentacles twice, a good omen for our daring spaghetti mission. Some say those tentacles can sense hidden spice routes.\nStay tuned for more updates from our floating festival of noodles and nautical nonsense.",
    "description": "Launch Day",
    "tags": [],
    "title": "Day 1",
    "uri": "/hugo-theme-relearn/exampleSite/log/first-day/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "Overview Up in the Upper Decks, our lookout is either spotting treasure or taking an unauthorized nap in the Crow’s Nest, while the helmsman tries to convince everyone that yes, that spinning wheel actually does something.\nIn Midst Ship, the Captain’s busy adding another gold tassel to their hat collection, and the crew quarters are hosting the weekly “Who Stole My Last Clean Sock” investigation.\nDown in Cargo, well… let’s just say what the health inspector doesn’t know won’t hurt them. Between the mysteriously moving crates and that barrel of pickles that’s been fermenting since the last century, it’s quite an adventure.\nMap graph TD A[The Purple Pulpo] --\u003e B1[Upper Decks] A --\u003e B2[Midst Ship] A --\u003e B3[Cargo] B1 --\u003e C11[Crow's Nest] B1 --\u003e C12[The Helm] B2 --\u003e C21[Captain's Cabin] B2 --\u003e C22[Crew Quarters] click B1 \"upper\" \"View Upper Decks\" click B2 \"midst\" \"View Midst Ship\" click B3 \"cargo\" \"View Cargo\" click C11 \"upper/nest\" \"View Crow's Nest\" click C12 \"upper/helm\" \"View the Helm\" click C21 \"midst/captain\" \"View the Captain's Cabin\" click C22 \"midst/crew\" \"View the Crew Quarters\" style A fill:mediumpurple,stroke:rebeccapurple,stroke-width:4px style B1 fill:mediumvioletred,stroke:purple,stroke-width:4px style C11 fill:mediumvioletred,stroke:purple,stroke-width:4px style C12 fill:mediumvioletred,stroke:purple,stroke-width:4px style B2 fill:dodgerblue,stroke:royalblue,stroke-width:4px style C21 fill:dodgerblue,stroke:royalblue,stroke-width:4px style C22 fill:dodgerblue,stroke:royalblue,stroke-width:4px style B3 fill:darkturquoise,stroke:teal,stroke-width:4px",
    "description": "Overview of the ship",
    "tags": [],
    "title": "The Ship",
    "uri": "/hugo-theme-relearn/exampleSite/ship/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship",
    "content": "The highest point of our mighty vessel! Up here, the crow’s nest scout shouts coordinates to our helmsman below, though sometimes they’re just playing an elaborate game of maritime telephone. The crow’s nest offers the best views in the house (or ship), perfect for spotting incoming weather, distant lands, or that seagull that keeps stealing the captain’s lunch.\nCrow's Nest Where our lookout pretends to spot land while actually napping\nThe Helm Home to our steering wheel, which may or may not be connected to anything",
    "description": "Where seagulls dare to land and captains steer with flair",
    "tags": [],
    "title": "Upper Decks",
    "uri": "/hugo-theme-relearn/exampleSite/ship/upper/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "【开发问题】linux启动docker镜像成功，而win启动该镜像mysql报错 dockers报错：Starting MySQL database server mysqld …failed 进入容器内部，查看mysql错误日志：cat /var/log/mysql/error.log mysql具体报错：Different lower_case_table_names settings for server ('2') and data dictionary ('0').\n自顶向下学习K8S–部署Agones 学一个新事物从底层理论学肯定是最系统的，但不是最工程的。对于K8S，我个人认为相比苦苦理解各种集群，节点，pods等等概念，不如实际上手一次，从实践上逐步理解理论，自顶向下才是最快最高效的学习模式，因为目的是使用K8S，是工程化，而不是了解k8s架构，设计云云。\nphp使用grpc服务(从0开始，并且包含mapfield文件解释) grpc是面对微服务框架而风生水起的，上次我用python编写了一个图神经网络处理的微服务，使用grpc放在我的服务器本地端口上。 现在我希望我的一个php项目也可以调用该服务，现在来试一试吧~\n使用grpc在go后端和python服务间通信 gRPC是Google 开发的高性能、开源的远程过程调用（RPC）框架，基于 HTTP/2 协议进行通信，使用 Protocol Buffers（protobuf）作为接口定义语言，可以看为一种协议。grpc可以用于各种不同服务间的通信，屏蔽底层细节(如编程语言，操作系统等)\nTypecho中代码高亮并有Mac风格 下载prism文件。在head中引用，并添加行号类。修改CSS。\nTelegram Bot部署 从botfather处创建bot，命名为 vio.明确使用需求和目的，进而选择开发工具和相关库(主要使用go和colly库，tg官方也有go的api库)",
    "description": "【开发问题】linux启动docker镜像成功，而win启动该镜像mysql报错 dockers报错：Starting MySQL database server mysqld …failed 进入容器内部，查看mysql错误日志：cat /var/log/mysql/error.log mysql具体报错：Different lower_case_table_names settings for server ('2') and data dictionary ('0').\n自顶向下学习K8S–部署Agones 学一个新事物从底层理论学肯定是最系统的，但不是最工程的。对于K8S，我个人认为相比苦苦理解各种集群，节点，pods等等概念，不如实际上手一次，从实践上逐步理解理论，自顶向下才是最快最高效的学习模式，因为目的是使用K8S，是工程化，而不是了解k8s架构，设计云云。\nphp使用grpc服务(从0开始，并且包含mapfield文件解释) grpc是面对微服务框架而风生水起的，上次我用python编写了一个图神经网络处理的微服务，使用grpc放在我的服务器本地端口上。 现在我希望我的一个php项目也可以调用该服务，现在来试一试吧~\n使用grpc在go后端和python服务间通信 gRPC是Google 开发的高性能、开源的远程过程调用（RPC）框架，基于 HTTP/2 协议进行通信，使用 Protocol Buffers（protobuf）作为接口定义语言，可以看为一种协议。grpc可以用于各种不同服务间的通信，屏蔽底层细节(如编程语言，操作系统等)",
    "tags": [],
    "title": "Web",
    "uri": "/hugo-theme-relearn/exampleSite/web/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "Captain Hugo reporting from the quarterdeck of the magnificent The Purple Pulpo. The seas are fair, and our hold is brimming with exotic cargo bound for distant ports. Our seasoned crew stands ready for another adventure across the Seven Seas.\nOperation Squid Spaghetti Our midnight run involved top-secret pasta flour and premium marinara crucial for the realm’s spiciest mission. The crew was amped!\nDay 1 Launch Day\nDay 2 At Sea\nDay 3 Island Arrival",
    "description": "The Captain's Log",
    "tags": [],
    "title": "Captain's Log",
    "uri": "/hugo-theme-relearn/exampleSite/log/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Captain's Log",
    "content": "At Sea Captain’s Log, 0545 hours\n“A little sea spray can’t break our spirit—nor our appetite!”\n– The Chef, after a minor sauce-spill incident\nThe waves crash and the crew awakens to the salty sea breeze. Our beloved ship, The Purple Pulpo, plows forward, determined to complete our “Operation Squid Spaghetti.”\nStatus Weather: Slightly stormy with a touch of dramatic sea mist Crew Morale: Excitement level: High Hunger level: Astronomical Willingness to sing shanties: ∞ Culinary Update The kitchen rattles with every wave, saucepans clanging like a symphony of disorganized percussion. Marinara overboard? Twice. But fear not, the crew valiantly rescued the floating ladle, dubbing it Sir Stir-a-Lot.\nStay tuned for the next thrilling entry: How fresh noodles fare in gale-force winds… and whether the sauce can hold up against the unstoppable appetite of seafaring sailors!",
    "description": "At Sea",
    "tags": [],
    "title": "Day 2",
    "uri": "/hugo-theme-relearn/exampleSite/log/second-day/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship",
    "content": "The heart of shipboard shenanigans, where the captain’s dignified stride from their cabin inevitably collides with sailors rolling barrels across the deck.\nCoffee aromas from the Captain’s cabin wage a constant battle with the hearty snores echoing from the crew bunks. It’s that magical space where formal reports mysteriously acquire coffee rings, and the crew’s sea shanties somehow find their way through the captain’s supposedly soundproof door.\nA daily theater of nautical life where rank meets reality, and everyone pretends not to notice the first mate sleepwalking in their pajamas.\nCaptain's Cabin A luxurious 4x4 room, home to our beloved Captain Hugo, with a genuine fake window\nCrew Quarters Where dreams of mutiny and tales of sea monsters are equally shared",
    "description": "Where captains and crew collide in organized chaos",
    "tags": [],
    "title": "Midst Ship",
    "uri": "/hugo-theme-relearn/exampleSite/ship/midst/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "用最轻量的VS负载进行UE5开发(使用rider) vs的C桌面开发环境还是挺重要的，很多软件都可能会用到(比如AI音声生成–TTS，有的项目也要其SDK)，早下晚下罢了。同样的，ue5没有vs是不行的，rider可没有c编译器和c++开发环境，所以vs该下还是要下。因为有了rider，那么如何不下载vs的编辑器，最轻量的进行UE5开发呢。",
    "description": "用最轻量的VS负载进行UE5开发(使用rider) vs的C桌面开发环境还是挺重要的，很多软件都可能会用到(比如AI音声生成–TTS，有的项目也要其SDK)，早下晚下罢了。同样的，ue5没有vs是不行的，rider可没有c编译器和c++开发环境，所以vs该下还是要下。因为有了rider，那么如何不下载vs的编辑器，最轻量的进行UE5开发呢。",
    "tags": [],
    "title": "Game",
    "uri": "/hugo-theme-relearn/exampleSite/game/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "Face it This is an example site for the Relearn theme of the Hugo static site generator.\nIt displays content about the fictional ship The Purple Pulpo in English and a crude Piratish accent. Don’t take it too serious.\nThe goal with this site is to showcase a minimal example with as less configuration as possible. It is meant to be a starting point for your own website. The configuration files are documented to help you understand the reason behind certain settings.\nRun it The source code for this website is contained in the Relearn repository. After the installation of Hugo you can build the site locally from inside the exampleSite directory with\nhugo server Then you can access the site by navigating to http://localhost:1313 in your browser.\nFor a detailed installation guide, see the Relearn documentation.\nModify it While minimal in configuration, this showcase contains an auto translation into the Piratish language. This required some additional files and directories, totally unnecessary for a simple site. You can delete them if you use this site as a starting template. Namely these are:\ncontent/pir/ i18n/ layouts/partials/shortcodes/piratify.html layouts/partials/toc.html layouts/shortcodes/piratify.html You will also have to add this to the hugo.toml to deactivate the translation:\n​ hugo.toml disableLanguages = ['pir'] or remove all references to the Piratish language.",
    "description": "About this Website",
    "tags": [],
    "title": "About",
    "uri": "/hugo-theme-relearn/exampleSite/about/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship",
    "content": "Where organization meets chaos and inventory management is more of a suggestion than a rule. Our state-of-the-art cargo facilities are divided into three distinctly disorganized bays.\nThe daily operations in our cargo bays resemble an interpretive dance of logistics, where inventory lists are more like creative writing exercises. Our automated sorting system, powered by quantum probability and caffeinated algorithms, occasionally decides to reorganize items based on their cosmic aura rather than traditional categories. This has led to fascinating discoveries, like finding out that rubber ducks and miniature black holes share remarkably similar energy signatures.\nThe deck crew has developed their own unique navigation system through the chaos, using a combination of intuition, lucky guesses, and the occasional guidance from our resident AI, which has developed a peculiar fondness for storing items in patterns that resemble abstract art. The resulting arrangement has been praised by visiting space artists as “a masterpiece of organized entropy” and “the most innovative storage solution since the invention of pocket dimensions.”\n​ Cargo Bay Alpha Cargo Bay Beta Cargo Bay Gamma 3,721 rubber ducks in spacesuits One very large tea cozy (planet-sized) Collection of anti-gravity hamster wheels Emergency supply of digital cookies Quantum-entangled sock pairs Library of dehydrated books Self-folding origami robots Tank of compressed rainbow matter Zero-gravity bubble wrap (extra bouncy) Time-traveling toast machine Collection of miniature black holes (safely contained) Spare parts for the ship’s interpretive dance module",
    "description": "Where organization meets chaos",
    "tags": [],
    "title": "Cargo",
    "uri": "/hugo-theme-relearn/exampleSite/ship/cargo/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Captain's Log",
    "content": "Island Arrival Captain’s Log, 1140 hours\n“Ahoy, pasta-lovers! Our mission is finally a sauce-cess!”\n– The Enthused Quartermaster\nThe sun blazes overhead, revealing an island coastline shaped like a questionable noodle bowl — the perfect destination for our midnight pasta cargo.\nStatus Purple sails flutter in the island breeze The octopus figurehead is oddly shining—some claim the wooden tentacles are still dancing to an unseen rhythm Slight tang of marinara lingers across the entire deck Incident in the Crow’s Nest Upon our arrival in the harbor, the lookout nearly toppled from his perch in a fit of excitement. A mysterious figure on the dock signaled with a lantern three times—followed by a deafening call of a heron in flight.\nThe lookout swears the bird cawed in perfect Morse code, as if warning us of impending calamity. Moments later, a sudden gust toppled the spyglass stand, sending it clattering down to the quarterdeck, just as the heron sped off with a triumphant whistle.\nMission Debriefing Crates of sauce offloaded with care (and the occasional accidental slosh) Crowds of locals, excited for fresh spaghetti Squid ink banner hoisted high to announce “Operation Squid Spaghetti Complete”",
    "description": "Island Arrival",
    "tags": [],
    "title": "Day 3",
    "uri": "/hugo-theme-relearn/exampleSite/log/third-day/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "短期回顾2024/8 这段时间没做什么项目相关，自上次gamejam之后，只接手了一个游戏的后端项目，但短期内暂无后续。我自己还是看好这个项目的，和我未来的规划不谋而合吧，很乐意合作。\nGamejam记录-2024CIGA 第一次参加gamejam，还是有难得的体会的。我是负责程序的部分，奈何工期不够，最后演示的时候游戏还是有诸多bug，让策划老哥上台受窘了hh。但是最后我也完成了几乎所有bug的修复，上传到了itch.io网站. 并且演示视频也发到了b站：https://www.bilibili.com/video/BV1GfaHeRE3h/?spm_id_from=333.999.0.0\n毕业致谢! 为了论文篇幅完整性和一些私人性，我的毕业致谢并不完整，我在此做些补充\n清明记事 2024年清明节的记事\n随笔 test this is a test file",
    "description": "短期回顾2024/8 这段时间没做什么项目相关，自上次gamejam之后，只接手了一个游戏的后端项目，但短期内暂无后续。我自己还是看好这个项目的，和我未来的规划不谋而合吧，很乐意合作。\nGamejam记录-2024CIGA 第一次参加gamejam，还是有难得的体会的。我是负责程序的部分，奈何工期不够，最后演示的时候游戏还是有诸多bug，让策划老哥上台受窘了hh。但是最后我也完成了几乎所有bug的修复，上传到了itch.io网站. 并且演示视频也发到了b站：https://www.bilibili.com/video/BV1GfaHeRE3h/?spm_id_from=333.999.0.0\n毕业致谢! 为了论文篇幅完整性和一些私人性，我的毕业致谢并不完整，我在此做些补充\n清明记事 2024年清明节的记事\n随笔 test this is a test file",
    "tags": [],
    "title": "Thinking",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "TLS流量解密，mitmproxy抓包模拟器流量走clash代理证书问题 所谓tls加密，其实就是https，或者是wss，但是wss也是https的升级。所以解密tls实际上就是解读https流量。 问题场景 工具： mitmproxy,mumu模拟器12，clash，wireshake(可选)，openssl，adb调试\n【逆向】解决unity导出TextAsset后部分文本出现乱码 该文件是通过解包软件从ab包直接导出的，不存在ab包加密的问题。既然部分文本可读，那么该文件加密的可能性很小，部分加密这种也太小众了。",
    "description": "TLS流量解密，mitmproxy抓包模拟器流量走clash代理证书问题 所谓tls加密，其实就是https，或者是wss，但是wss也是https的升级。所以解密tls实际上就是解读https流量。 问题场景 工具： mitmproxy,mumu模拟器12，clash，wireshake(可选)，openssl，adb调试\n【逆向】解决unity导出TextAsset后部分文本出现乱码 该文件是通过解包软件从ab包直接导出的，不存在ab包加密的问题。既然部分文本可读，那么该文件加密的可能性很小，部分加密这种也太小众了。",
    "tags": [],
    "title": "Reversing",
    "uri": "/hugo-theme-relearn/exampleSite/reversing/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Bot",
    "uri": "/hugo-theme-relearn/exampleSite/tags/bot/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Chatgpt",
    "uri": "/hugo-theme-relearn/exampleSite/tags/chatgpt/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Go",
    "uri": "/hugo-theme-relearn/exampleSite/tags/go/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Gocqhttp",
    "uri": "/hugo-theme-relearn/exampleSite/tags/gocqhttp/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Paas",
    "uri": "/hugo-theme-relearn/exampleSite/tags/paas/index.html"
  },
  {
    "breadcrumb": "",
    "content": "“When The Purple Pulpo sets sail, even the fish hold their breath.”\n– Old fisherman’s tale\nThe year is 1623. An unusual ship, The Purple Pulpo, emerges from the foggy sea, its sails dyed a brilliant purple that dazzles friend and foe alike. Cunning merchants whisper about a legendary octopus figurehead carved from driftwood—some say it dances under moonlight to ward off pesky sea ghosts (and suspicious tax collectors).\nMyths and Rumors Though many debate its authenticity, rumor has it the captain once successfully traded a shipload of questionable sea cucumbers for a cargo of prized purple velvet. The hue of the velvet supposedly matched the exact shade of the boat—thus reinforcing its flamboyant reputation.\nPossible Explanations A wizard was on board, casting color illusions for fun. The purple paint was accidentally created by mixing octopus ink into the ship’s pigment. Too much wine spilled on deck over many voyages. (Captain’s favorite theory.) Unlikely Allies It is said, one day a rival trading ship, the Lady Kraken, tried to outdo The Purple Pulpo by painting their masts hot pink. The clash at sea was more of a fashion show than a naval battle – onlookers cheered for hours, forgetting they were late for dinner.\nAdventures Read about some of the unbelievable adventures of The Purple Pulpo in the Captain’s Log. Notable adventures include:\nOperation Squid Spaghetti: A midnight run delivering spaghetti to stranded islanders, guided only by the glowing luminescence of algae (and embarrassed jellyfish who offered moral support). The Great Spice Heist: Smuggled saffron and paprika past rival pirate ships. Legend claims the pirates were too busy sneezing to put up any fight. A Final Toast Raise your mug of (purple) punch to The Purple Pulpo – where cargo, captain, and cephalopod might just change the hue of history. May your sails forever billow, your hull remain bold, and your cargo be as colorful as your legend!",
    "description": "",
    "tags": [],
    "title": "The Purple Pulpo",
    "uri": "/hugo-theme-relearn/exampleSite/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Qqbot",
    "uri": "/hugo-theme-relearn/exampleSite/tags/qqbot/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/hugo-theme-relearn/exampleSite/tags/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "纯go编写的机器人业务后端，bot取名为 Vio ，qq机器人的实现基于gocq提供的api，基于gocq的上报事件调用转发外部讯息并返回。 可以完成基于chatgpt聊天任务，以及一些简单的指令响应。\n如果你有想法和意见请提issue！这对我和bot都很重要！ 欢迎qq加群讨论：340961300\n实现平台以及实现的外部功能:\nQQ bot 随机涩图 猎杀对决枪声语音 发送已撤回的消息 禁言抽奖 Telegram bot(暂时已停止开发) 写在前面/Preface 有部署聊天机器人的想法，但是我使用的国内服务器，而且服务器性能也一般，于是决定不用云服务器部署了，找个国外的Paas平台，把写的后端送上去就好了。\n目前已经完成了：\n天然支持http请求，使用go原生net包，创建了一个 /post请求的路由，可以解析post内容转发调用chatgpt的api 为Tg设置了webhook，可以监听tg服务器的消息，实现tgbot。针对Telegram的消息处理，对私人，群组，超级群组各有不同的应答模式。 配合go-cqhttp使用，用于实现qqbot,基于上报事件，调用gocq提供的api进行回复。注意参考gocq官方文档。可以调用api发送图片，随机图片api参考 AI调用：\n目前只支持了chatGPT，调用其api进行回复。该功能使用了go-openai库，支持了go语言对openai api的调用 提示词参考：awesome-chatgpt-prompts-zh 结构说明 AI： 提供ai服务，从ai_server文件中驱动，子文件为具体的api的调用实现。 config： 定义环境变量结构体 docs: 文档页面，使用 docsify gocq： qqbot的业务层核心。 command: 最业务层的逻辑，使用各种基础设施和其他服务，完成机器人指令的调用 cqCode: 定义qq消息中cq码的结构体，实现编码和解码 cqEvent: 属于gocq中事件的定义，只用于参考，未使用其结构体 event: 监听上报事情后的处理入口 gocq_resp_params: 响应参数的结构体定义 gocq_send_params: 发送参数的结构体定义 gocq_sender: gocq的发送者实例，用于api调用 gocq_server: 在这里注册了一个gocq的单例，全局调用gocq相关的基础设施 server： 创建or使用服务(http,ws,tgbot) handler: 处理http和请求以及ws请求 server: 使用依赖注入启动各种服务 unused: 未实现，或者搁置的功能，如tgbot utils: 调用外界功能的函数库和工具库 实现要点 服务层注册基础设施，如redis(目前只搭载了redis缓存，用于存放部分聊天数据)，通过依赖注入的方式激活其他只能单个存在的服务，如gocq服务(依赖ws连接存在，ws连接只有一次，所以是个全局单例)。 gocq服务在handler中进行ws连接的时候完全创建，因为ws连接读消息是阻塞的，为了实现并发，在gocq服务中，我创建了一个消息发送者，一个消息队列，以及一个响应map。handler中只处理接受到的上报事件，把接受到的响应存放在一个channel中，在具体需要响应数据的地方去pop。响应map是根据响应中的echo映射指定的响应数据。这样实现了消息接受，发送和处理的解耦，可以同时并发处理。 redis的作用：最简单的场景，存放撤回的消息id，因为未知需要取用该撤回的消息的时机，存放在redis中方便需要的时候进行api调用取到该消息。目前使用的是heroku的add-ons的redis组件，也是通过环境变量读取redis的url地址进行注册：REDISCLOUD_URL AI服务: 预计支持多种ai的调用，目前已经完成了ai服务的代码解耦并且结构化，便于扩充。 前端设计: 预计做成一个后台管理面板，精力有限，会使用直接模板，注重功能的实现，不只聊天！ 结构体设计完全遵循gocq文档 使用go的websocket库创建和qqbot的ws连接，为基于gocq的qqbot的服务入口。 gocq的配置建议阅读我的个人博客 chatgpt的调用参考go的openai库文档即可，也很完善。注意调用api是无法进行联系上下文对话的，要实现上下文对话只有把历史消息都post给api，这显然是不现实的。 部署建议 我推荐放在paas上，key和密钥是通过环境变量读取的，也就是config中定义的字段。 因为tgbot要求后端webhook地址必须有证书，也就是https访问。一般paas平台都会自带证书的，放自己服务器上需要自己配证书服务，麻烦点，并且需要修改项目中读取环境变量的代码，改为读取配置文件(新建).\n我是放在heroku这个paas平台，国外的，可以通过github学生包免费使用，但是需要绑定国外visa卡。\n之前也有使用过Zeabur，国人开发的，discord上官方也很活跃，如果服务请求不多，可以使用，每月有5刀的免费额度，无需绑卡。\npaas推荐 Heroku Zeabur 更多paas相关信息，可以查询 Free for dev中的列表.\nZeabur挺不错，国内社区，discord上回复也很即使，一键部署挺快的，github集成。 zeabur上项目部署非常快,甚至不用写dockfile,而且对go项目有完整的支持,算是符合他们的口号:\nDeploying your service with one click\n但是Zeabur每月5$，如果是聊天机器人，按量付费肯定是不够的。\nHeroku只有欧洲和美国的部署点，但也是git集成，非常方便，现在我已经转移到了heroku，主要我有github学生包，可以白嫖heroku\nheroku注册要关闭adguard，需要绑定国外银行卡，绑卡时建议关闭梯子。\nPaas部署注意点 端口号 注意一下项目的端口号设置,最好设置在环境变量中,然后在项目中通过 os.Getenv(\"xxx\")来获取端口号.\n支持go部署的paas中，环境变量 PORT 一般都默认8080，且为全局的。无需写入环境变量，直接调用就好了。\n对于tgbot：官方示例中使用的8443端口，在部署到paas平台时8443端口需要确认是否开放。 tgbot证书问题 heroku和zeabur部署项目自带证书,做完域名映射可以直接https访问. 所以在设置webhook进行和tg服务器通讯的时候不需要手动加载 cert.pem 和 key.pem\n在部署tg的bot时,可以修改tgbot官方对go语言搭建bot示例中的:\n... log.Printf(\"Authorized on account %s\", bot.Self.UserName) wh, _ := tgbotapi.NewWebhook(TG_WEBHOOK_URL + bot.Token) ... go http.ListenAndServe(\":\"+port, nil) 直接使用 NewWebhook和 ListenAndServe函数即可.\n环境变量 实例定义四个环境变量\nTG_WEBHOOK_URL=https://yousite.com/tgbot BOT_TOKEN=your token chatGPTAPIKey=sk-your key ChatGPTURL_proxy = \"https://your-proxy-site/v1\" tips: 免费的gpt api的代理 -\u003e ChatGPTURL_proxy=\"https://one-api.bltcy.top/v1\"",
    "description": "纯go编写的机器人业务后端，bot取名为 Vio ，qq机器人的实现基于gocq提供的api，基于gocq的上报事件调用转发外部讯息并返回。 可以完成基于chatgpt聊天任务，以及一些简单的指令响应。\n如果你有想法和意见请提issue！这对我和bot都很重要！ 欢迎qq加群讨论：340961300",
    "tags": [
      "Go",
      "Gocqhttp",
      "Chatgpt",
      "Bot",
      "Qqbot",
      "Paas"
    ],
    "title": "VioGo--不止聊天的奇妙bot",
    "uri": "/hugo-theme-relearn/exampleSite/project/viogo/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "预告信生成器国外作者原版：https://skyventuree.github.io/p5cc/index.html\n我制作了api版本供生产或娱乐使用。网页版有汉化版但最近网站貌似挂了，如果反响好我就自己部署一个网页版公开下。\n本人将网页版生成器的js代码逻辑使用go语言进行了重写和部署，并开放了其api，可以直接通过get方法获取预告信的png。get方法只能最简单的绘制文本，post方法基本集成所有功能，提供了换行功能等，Text中加入换行符\"\\n\"即可。\nGitHub页面：https://github.com/viogami/WebAPI/tree/master/p5cc\n快速开始\nhttp://api.viogami.tech/p5cc/:text\neg: http://api.viogami.tech/p5cc/persona5\n感谢p5r风格字体的制作者和预告信样式的制作者 使用了golang的gg库进行绘图。提供了GET方法和POST方法。GET使用动态路由直接生成，POST参数示例如下：\ntext: \"persona5\" fontSize: 120 # 字体大小 gutter : 10 # 字体间距 padding : 240 # 文字边距 textAlign: center # 文字对齐方式 showLogo: true # 是否显示Logo logoScale: 1.0 # Logo缩放比例 logoOffset: 240 # Logo偏移量 showWtm: \"\" # 水印文字，为空则不显示 字体暂时不可更改，默认使用了 HarmonyOSSansSC-Bold.ttf\nCredits Persona 5 © ATLUS. © SEGA.\nThis repositories`s cord forks from p5cc\nAssets:\nPersona 5 Calling Card Base by Elmind. Persona 5 Style Text Generator by @LzxHahaha. Ported and modified by sorae42. Persona 5 Logo and Assets by ALTUS. All assets are all under fair use.\nCredits can also be seen on the website along with links to the original site and owners, at the bottom of the page.",
    "description": "预告信生成器国外作者原版：https://skyventuree.github.io/p5cc/index.html.我制作了api版本供生产或娱乐使用。网页版有汉化版但最近网站貌似挂了，如果反响好我就自己部署一个网页版公开下。",
    "tags": [],
    "title": "p5r预告信生成器API",
    "uri": "/hugo-theme-relearn/exampleSite/project/p5r_p5cc/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Clash",
    "uri": "/hugo-theme-relearn/exampleSite/tags/clash/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Mitmproxy",
    "uri": "/hugo-theme-relearn/exampleSite/tags/mitmproxy/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: TLS",
    "uri": "/hugo-theme-relearn/exampleSite/tags/tls/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Reversing",
    "content": "所谓tls加密，其实就是https，或者是wss，但是wss也是https的升级。所以解密tls实际上就是解读https流量。\n问题场景 工具： mitmproxy,mumu模拟器12，clash，wireshake(可选)，openssl，adb调试\nmumu模拟器启动游戏，希望抓其传向服务器的包，实现一些自动化操作。由于游戏是日服，所以需要启用代理。我使用了clash。此外，游戏的包使用了tls1.3加密，要想截取必须获得在本地生成的密钥进行解密才能知道明文。中间人代理，我使用了mitmproxy。\n问题显露 mitmproxy可以代理一个本地端口，在tls(https)流量进入进行握手阶段的时候，通过配置证书可以解读明文.但问题是流量必须走clash的，不然没梯子访问不了国外的服务器。而clash作为代理工具是没有保存该key的功能的。\n思路 很自然的想法，让模拟器流量先走mitmproxy，而后再走clash作为流量出入口，mitmproxy作为模拟器和clash的中间人。这样就可以实现流量的截取和梯子转发，最后通过如wireshark这类的抓包工具进行数据包分析。\n证书问题 这样看起来ok了，模拟器访问网页，在终端也可以看到mitmproxy的流量经过了。但是在启动游戏的时候，依然会看到如下报错：\nclinet TLS handshake failed. The client may not trust the proxys certificate for xxx.com(Openssl Error ssl routines , , tlsv1 alert access denied)\n字面意思，mitmproxy 在进行 TLS 握手时，客户端无法信任 mitmproxy 的证书。通常情况下，mitmproxy 会自动生成一个伪造的证书来替代目标网站的真实证书，以便解密和转发流量。如果客户端（例如浏览器或模拟器）没有信任 mitmproxy 的证书，它就会拒绝与代理的安全连接。\n那就得在模拟器安装上mitmproxy的证书。 默认情况下，mitmproxy 的证书存储路径是 ~/.mitmproxy/（Linux/macOS）或 C:\\Users\u003cusername\u003e.mitmproxy\\（Windows），其中有一个文件叫 mitmproxy-ca-cert.pem。 将 mitmproxy-ca-cert.pem 证书文件传输到 Android 设备或模拟器。 打开设备的 设置，找到 安全性 或 证书管理，然后选择 从存储导入证书。 选择下载的证书文件并导入。 导入后，设备应该信任 mitmproxy 的根证书。\n但是mumu12模拟器没有如上设置。并不是无他法。 第一步，安装openssl 第二步，把pem证书通过openssl转换为DER格式的证书\nopenssl x509 -subject_hash_old -in mitmproxy-ca-cert.pem.pem\n第三步，重命名pem文件为 哈希值.0 adb root adb remount adb push xxxxxxx.0 /system/etc/security/cacerts/ 参考帖子：https://blog.csdn.net/haduwi/article/details/125696208\n结束 导入了证书后，mitmproxy的event log就没有报错了，美滋滋，开始用wireshark进行数据包分析吧。",
    "description": "所谓tls加密，其实就是https，或者是wss，但是wss也是https的升级。所以解密tls实际上就是解读https流量。\n问题场景 工具： mitmproxy,mumu模拟器12，clash，wireshake(可选)，openssl，adb调试",
    "tags": [
      "TLS",
      "Mitmproxy",
      "Clash",
      "模拟器"
    ],
    "title": "TLS流量解密，mitmproxy抓包模拟器流量走clash代理证书问题",
    "uri": "/hugo-theme-relearn/exampleSite/reversing/tls-mitmproxy-clash/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 模拟器",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Reversing",
    "content": "问题预览。可以看到，这是个配置文件，但是只有部分文本可读。\n该文件是通过解包软件从ab包直接导出的，不存在ab包加密的问题。 既然部分文本可读，那么该文件加密的可能性很小，部分加密这种也太小众了。\n既然是游戏工程项目，考虑两个方向：是否是用protobuff读取的二进制文件；是否是直接用读取字节流的方式读取的配置文件。\n是否是pb的二进制文件？ 直接拿到导出的二级进制文件导出到该网站识别： https://protobuf-decoder.netlify.app/\n可以看到，没有识别出合适的字段名。据此判断该文本文件不是pb的二进制文件。\n是否是按字节流读取的文本？ 按照字节流读取文本，这在客户端中不少见, 因为比json省空间, 但缺点是可读性为0, 我的评价就是狗屎, 你少出几张宽高不是4的整倍数的图, 这都不用扣这点配置表省的空间。。在源码中可能是这样出现的： 使用010 editor打开该二进制文件。逐字节进行观察分析：所有配置文件都有相同的4B文件头，随后是文件长度的16进制，然后是相同的4B字节“00 00 00 01”,再之后是配置文件的配置项数，最后是4B的校验比特。总之就是开头的20B为配置文件的描述文件头。 获得二进制文本的字段描述 此处需要逆向代码，由于是ill2cpp打包的，只能dump出函数名，但也够用了。在dnspy中搜索和配置文件同名的项，可以找到一个定义了所有配置文件model的文件夹ResDef。其中定义了配置文件的字段内容： 该项目确实是用protobuff进行通信的，但配置文件还是json格式的，其中配置字段也符合json嵌套的格式。我们逐比特进行字段解读，发现字节流确实是可读的。其中需要注意以下三点：\n这种由开发者自定义的二进制文件，一般都是大端序读取的字节，直接用readbytes方法不合适，要逆序一下。 注意其中的string类型的比特编码方式，一般是由4B文件指定长度，后面该长度的字节编码为字符串。 注意数组类型在字节流文件中的编码方式，可能和字符串一样用4B指定长度，也可能是定长编码。本示例项目中就是定长编码，所有数组大小都固定为3。 配置字段的定义如下：\npublic class AchieveBaseConfig : ProtoBaseStruct { public int SortNO; public uint ID; public string Desc; public byte Classify; public byte ClassifySubType; public byte ShowProgress; public ResBehaviorRule Behavior; public uint BootyID; public uint MaxProgress; public uint JumpID; } public class ResBehaviorRule : ProtoBaseStruct { public int ID; public int Type; public int[] Param; } 逐比特对比，符合字段的定义： 编写解密代码 编写解密函数类BinaryConfigParser，根据字段类型逐行读取，注意大小端处理，字符串和数组类型处理以及嵌套类型的处理(需要递归)，最后在主函数中调用。如下只给出主函数的调用部分，BinaryConfigParser类过长，且解码不同二进制文件方法也不相同，就未放出，如需要可留言。\nusing Newtonsoft.Json; class Program { // 解码二进制文件 static void Decode(string fileName, int arrayLen) { string binaryFilePath = $\"TextAsset\\\\{fileName}\"; // 替换为实际的二进制文件路径 // 动态获取类型 Type type = Type.GetType($\"ResDef.{fileName}\"); // 动态调用泛型方法 var method = typeof(BinaryConfigParser).GetMethod(\"ReadConfigArray\").MakeGenericMethod(type); // 读取配置项 var configs = method.Invoke(null, new object[] { binaryFilePath, arrayLen }); // 保存为 JSON 数组格式 string jsonArray = JsonConvert.SerializeObject(configs, Formatting.Indented); // 保存到文件 string jsonOutputPath = $\"output_json\\\\{fileName}.json\"; // 替换为实际的 JSON 要存放的文件路径 File.WriteAllText(jsonOutputPath, jsonArray); Console.WriteLine($\"文件 {fileName} 已解码为 JSON 文件: {jsonOutputPath}\"); } //自动化解码 static void AutoDecode() { string textAssetFolder = \"TextAsset\"; string outputFolder = \"output_json\"; // 确保输出文件夹存在 if (!Directory.Exists(outputFolder)) { Directory.CreateDirectory(outputFolder); } // 获取TextAsset文件夹下的所有文件 var files = Directory.GetFiles(textAssetFolder); // 遍历所有文件 foreach (var filePath in files) { string fileName = Path.GetFileName(filePath); string outputJsonPath = Path.Combine(outputFolder, $\"{fileName}.json\"); // 检查是否已生成JSON文件 if (!File.Exists(outputJsonPath)) { try { // // 输入固定数组长度,由于长度未知,所以循环100次，直到找到正确的长度 // for (int arrayLen = 0; arrayLen \u003c 100; arrayLen++) // { // // 调用Decode生成JSON // Decode(fileName, arrayLen); // } int arrayLen = 3; Decode(fileName, arrayLen); } catch (Exception ex) { Console.WriteLine($\"处理文件 {fileName} 失败！\"+ex.Message); } } } } // 程序入口 static void Main() { AutoDecode(); } }",
    "description": "该文件是通过解包软件从ab包直接导出的，不存在ab包加密的问题。既然部分文本可读，那么该文件加密的可能性很小，部分加密这种也太小众了。",
    "tags": [
      "Unity",
      "逆向",
      "游戏开发",
      "二进制文件",
      "Protobuf",
      "Json",
      "C#"
    ],
    "title": "【逆向】解决unity导出TextAsset后部分文本出现乱码",
    "uri": "/hugo-theme-relearn/exampleSite/reversing/decrypt-textasset-garbled/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: C#",
    "uri": "/hugo-theme-relearn/exampleSite/tags/c%23/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Json",
    "uri": "/hugo-theme-relearn/exampleSite/tags/json/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Protobuf",
    "uri": "/hugo-theme-relearn/exampleSite/tags/protobuf/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Unity",
    "uri": "/hugo-theme-relearn/exampleSite/tags/unity/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 二进制文件",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 游戏开发",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 逆向",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E9%80%86%E5%90%91/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking",
    "content": "这段时间没做什么项目相关，自上次gamejam之后，只接手了一个游戏的后端项目，但短期内暂无后续。我自己还是看好这个项目的，和我未来的规划不谋而合吧，很乐意合作。\n今日傍晚出去闲散，哼着\u003c雅俗共赏\u003e，思考着一些价值理念的问题。每天这个时候就像cpu要例行执行中断指令一样，大脑到内核态运行一段时间。人对事物的看法说是随着时间而变化，但实际上这个只是没有触发点。有时候在某种经历的加持下一想通了，思维马上就变化了。这个触发点就是随缘了，什么时候思考到什么时候就，突然的，变通了，缘分需要时间。\n最近看了智能路障的一期视频，讲的消费主义的，在这个主题的壳子里他还阐述了一些关于优越感，关于资本的发展与迎合受众之间的关系使我深感赞同。这也映射到圈子氛围的话题，为什么圈子大了大家都闹麻了，核心还是优越感丢了。人们需要小众的东西来彰显自己的不同，不同使得自己独特使得自己优越。这种心理的目的和想做第一，哗众取宠是相同的。\n我说以上还是想谈论我对一些二游心理认知的变化，我现在处于混沌邪恶派。大家一样烂大家都好似。\n早期我对游戏的认识来自与一种综合性的追崇，游戏是集动画，音乐，玩法，剧本于一体的综合性艺术，是大一统的思想表达体，是包罗的表现模式。但现在我又在做拆分，细化到游戏作曲内容，画面是什么风格，制作人什么背景，玩法是基于什么。这种分久必合合久必分的思维逻辑在长久的生活中屡见不鲜。比如web的前后端，从一体机到前后端分离，到node.js的一把梭到blazor的出现。分分合合，每时每刻需要模拟的场景的不同，需要的逻辑就不一样。 在进入一个领域之前，都希望这个领域可以包罗万象，集大成于一身。在熟悉这个领域后，又领悟到这个集大成的零件是需要缝缝补补的或者随着认知深入反而是感觉是丑陋和不堪的东西。\n二游的传统受众被新入圈的人的狂热发言汗颜，本就不待见传统用户的则合并同类项，前者只好自嘲的说着正义切割。 这太诡异了，鹊觉得这是鸠占鹊巢，鸠觉得这是鹊占鸠巢。面临的只有切割，也就是标签细分。标签是给圈外人了解圈子，留下刻板印象用的，但正如上文所述，人们需要独特的东西来彰显自己，标签也是合适的东西。万物标签化，形如json。好吧，这并没什么作用，临时现象罢了。我觉得准确的趋势是无论是什么标签，市场都会定制化的保留。虽然“三流企业才做产品”，但这种行业的模仿是探路的五彩石也是能否和用户双向奔赴的测试。 人们都需要点独特和优越来为自己的存在加权重，我们没理由指责任何人，我觉得任何人说任何话都可以，但不能来自一种临时主观的理由(比如心情)。现在咒骂某些标签的变味已经无效力了。过去觉得ok的氛围也许当时就有人觉得不ok了，就像回合制，你在之前出过牌了，损失和得到都是固定的了，现在是新的回合和历史无关。如果把心态调整为每回合都是新开始，又是另一种得失体验。\n我想革二游的命，我暗暗的下决心。畸形的市场需要改变，市场和用户是双向塑造的稳态，我不知道现状形成的大影响是什么，但是某种创造性的东西一定有这样的力量。\n我只是记录我的随想，嘈杂并且无序，但确实是我大脑工作的结果，我继续哼着歌 我窝在摇椅里乘凉，和楼下老爷爷一样ye~",
    "description": "这段时间没做什么项目相关，自上次gamejam之后，只接手了一个游戏的后端项目，但短期内暂无后续。我自己还是看好这个项目的，和我未来的规划不谋而合吧，很乐意合作。",
    "tags": [],
    "title": "短期回顾2024/8",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/review_2024-8/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e ",
    "content": "心跳文学社久闻大名，梗图也很多，但是原来是17年的游戏还是老美的，也没配音，一直没启动过。\n今天看到库存就想打开试试。21年做了plus版本，虽然还没配音，但是剧情我也想吃一次原味的，做个游玩时候的心情记录。\n经典青梅开局，什么gal文化输出到了老美啊，而且文学部他是真讨论文学啊，比古典部强。写作技巧也是实在话。游戏方式是选词加好感大概。前面都是正常的，就是女角色疑似有点没见过男人了。先塑造青梅然后毁掉是吧，我是一心一意战士，绝不重蹈诚哥覆辙。\n夏树的伏笔？感觉这角色事太多 前面莫妮卡暗示挺多，伏笔 不给我一心一意战士操作空间非要我选是吧，绷不住了，还不给选莫妮卡 推完了，包括支线。总之还是挺短的，果然在有心理预期的情况下玩游戏，体验肯定是达不到预期的。喜欢纱世里，莫妮卡正常点吧，纯对我好我怎么不接受呢 支线纯糖(褒义)，后面夏树和尤里剧情纯铝铜 dlc支线的核心我觉得可以概括为：\u003cfont color=pink\u003e发现自己值得被爱 \u003c/font\u003e 其实玩了支线倒挺共情夏树的，特指最后一部分。傲娇并不是极端化出来的属性，而是现实普遍存在的心理的夸张。总而言之 反正角色各自有各自的心理问题，这不是什么戏剧化的内容，至少我觉得一定程度上解释我为什么无脑选纱世里。",
    "description": "心跳文学社久闻大名，梗图也很多，但是原来是17年的游戏还是老美的，也没配音，一直没启动过。",
    "tags": [],
    "title": "DDLC实况吐槽",
    "uri": "/hugo-theme-relearn/exampleSite/_more/ddlc/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: CIGA",
    "uri": "/hugo-theme-relearn/exampleSite/tags/ciga/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Gamejam",
    "uri": "/hugo-theme-relearn/exampleSite/tags/gamejam/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking",
    "content": "第一次参加gamejam，还是有难得的体会的。我是负责程序的部分，奈何工期不够，最后演示的时候游戏还是有诸多bug，让策划老哥上台受窘了hh。但是最后我也完成了几乎所有bug的修复，上传到了itch.io网站. 并且演示视频也发到了b站：https://www.bilibili.com/video/BV1GfaHeRE3h/?spm_id_from=333.999.0.0\n开题 我是觉得游戏开发这样的事，还是大家线下一起讨论，一起开发才是最有乐趣的。 但是工期也挺感人，在开始前几天有一个程序因为太忙来不了，只能线下，好在我去gamejam线下场地拉到一个想要solo的大哥辅助我。(实际上线上的程序比我厉害太多，最后游戏内的人物移动逻辑还是他写的)。后来的朋友协助了游戏策划案的讨论和游戏UI的unity实现，还是帮了挺大忙的，不然我真的捉襟见肘。\n实际上我参加gamejam主要是想体验游戏开发的工作流和头脑风暴的乐趣。今年的主题是 limited and unlimited,有限和无限。 在题目公布的极短时间内，我们就想到了两个有趣的游戏内容实体：贪吃蛇和永动机。⚔️ 前者来源于衔尾蛇，有限的身体，无限的符号。后者更是字面意义上的扣题了。还是比较有趣的两个概念。\n讨论 当时我们贪吃蛇游戏的设计原型选定为 马里奥星球以及 诺基亚3D贪吃蛇。永动机的原型却没有完善的方案，有一个思路是做一个拼图游戏，实现一个永动机，参考 致命框架。在不断的讨论中，永动机还是没有思考到一个有趣的点，后面想做一个物理模拟的游戏，但是又逐渐搁置了。\n对于我而言，2天的开发时间，减去休息讨论等，实际的有效开发时间也就一天。体量肯定是很小的。我初次完成整个项目，对质量不敢打包票，但是我也希望我能把大家讨论的结果完美实现。\n在讨论到贪吃蛇的同时，我联想到了一个unity的feel插件的一个demo演示。其中就有一个贪吃蛇🐍。他做了改动，蛇吃了食物会短暂加速并变的灵动，但一定时间没吃到又会逐渐变回原型。我觉得这是个很有趣的点。最后在贪吃蛇和永动机不休的讨论需要拍板的时候，我选择了贪吃蛇，更容易实现，更容易拓展，永动机的思路说到底，我还是不明确的。(但实际上贪吃蛇要考虑的细节也很多啊)\n开发 选择了开发目标和方案，两个策划连夜写完了策划案，设计的原型就是诺基亚的3D贪吃蛇。但是我希望还是2D。如何做好3D，或者2.5D的游戏，我尚且没有实际体会。不敢冒风险，以及没有学习时间，gamejam果然还是有点准备好，我属于临阵没磨枪的，吃了点亏，贪吃蛇的基本实现还出了点问题，好在线上的程序帮我解决了。他也提出了策划意见相合的开发模式，但最后大家还是选择了2D。😶‍🌫️\n预期的效果是贪吃蛇可以在正反两面移动，正面空间受限，时间无限，吃到的东西变长。反面时间受限，空间无限，吃到东西变短。 蛇长度为0则死亡，吃到自己身体也死亡。玩家目标是得到更多的积分。正面两面的穿梭也十分有爽感，并且达成了扣题。\n但由于进度原因，不得不在项目上做一些减法，比如反转的动画效果，比如反面障碍物的生成算法。其实3D变成2D也是做了减法。时间还是挺紧张的，我开发的时候也遇到了一些不好解决的问题浪费了许多时间，最后一些特效也没来得及加上，挺可惜的。\n无论如何，到时间了就要上菜，几乎没有时间测试，测了几分钟大概hhh，就赶鸭子上架了。\n体会 体会到了什么？游戏开发的工作流，游戏业内人士的交流以及更多的朋友，更多的技术经验。\n实际上到了演示环节，我们的还是半成品，并且演示的时候还出现了一些未知的bug，自然受到的关注并不理想。而且扪心自问，我们做到游戏说到底也并没有太多有趣的点。 作为gamejam，游戏的包装并不重要，如果侧重玩法，就不要讲故事。 在演示环节有个组做的是个解密的游戏，画风是极简的，就几个线条元素，控制一个小球，点击可以加速到光速。到达指定的点为成功。游戏名叫光子，是个很不错的游戏。 有了这个体会，我觉得gamejam对美术的要求我觉得并不用太高，但是仍然是有备无患，多多益善。只是包装上面，我觉得并不强求。\n另一方面，我自己在最后也有一些bug难以修复，主要是因为我最初的原型没有做到完善。如果做一个贪吃蛇，就应该先把最基本的贪吃蛇逻辑写完美再做接下来的工作。因为前面的问题，和后面添加的功能发生了连锁反应，一时找不到原因。还有一个问题就是改动频繁导致的一些逻辑混乱。\n总之，尘埃落定，从讨论到立项到开发到几乎没有的测试到上台演示，也对实际的游戏开发有了一个小孔成像。感谢我的队友对我的支持，都是很有趣的人，希望有机会可以再一起做游戏，哈哈哈😎",
    "description": "第一次参加gamejam，还是有难得的体会的。我是负责程序的部分，奈何工期不够，最后演示的时候游戏还是有诸多bug，让策划老哥上台受窘了hh。但是最后我也完成了几乎所有bug的修复，上传到了itch.io网站. 并且演示视频也发到了b站：https://www.bilibili.com/video/BV1GfaHeRE3h/?spm_id_from=333.999.0.0",
    "tags": [
      "Gamejam",
      "Unity",
      "游戏开发",
      "CIGA",
      "贪吃蛇"
    ],
    "title": "Gamejam记录-2024CIGA",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/gamejam-2024ciga/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 贪吃蛇",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E8%B4%AA%E5%90%83%E8%9B%87/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: C++",
    "uri": "/hugo-theme-relearn/exampleSite/tags/c++/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: C++ Build Tools",
    "uri": "/hugo-theme-relearn/exampleSite/tags/c++-build-tools/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: C++ Cmake Tools for Windows",
    "uri": "/hugo-theme-relearn/exampleSite/tags/c++-cmake-tools-for-windows/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Rider",
    "uri": "/hugo-theme-relearn/exampleSite/tags/rider/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Ue5",
    "uri": "/hugo-theme-relearn/exampleSite/tags/ue5/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Vs2022",
    "uri": "/hugo-theme-relearn/exampleSite/tags/vs2022/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 开发环境",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Game",
    "content": "从UE5官方文档来看，要下的负载还是很多的。但查看rider官方文档，只要我们下一个vs的工具集就ok了，那就试试看。\n下载 Visual Studio Build Tools：\n访问 Visual Studio 官方网站 下载 Visual Studio Build Tools。\n运行安装程序，选择所需的组件：\n选择“C++ build tools”，这是最重要的部分。 在安装选项中选择： MSVC v142 - VS 2019 C++ x64/x86 build tools（或更高版本,我用2022） Windows 11 SDK（win10或更高版本） C++ CMake tools for Windows\n选择“单个组件”中的.NET框架SDK。\n开始安装，等待安装完成。\n配置 Unreal Engine 5 在完成上述步骤后，可以配置 Unreal Engine 5 使用这些工具来编译项目。\n1.启动 Unreal Engine 5 并打开项目。 2.转到“编辑” -\u003e “项目设置”。在左侧菜单中找到“平台” -\u003e “Windows”。确认编译器路径 指向刚安装的 MSVC 编译工具，vs2022。 3.转到”编辑器偏好设置“ -\u003e“通用” -\u003e “源代码” ，选择编辑器为 “rider”\n这样就完成了最轻量的使用rider做编辑器进行UE5开发了，不下载vs2022的编辑器，只下载必要构建工具，编辑器使用rider。",
    "description": "vs的C桌面开发环境还是挺重要的，很多软件都可能会用到(比如AI音声生成–TTS，有的项目也要其SDK)，早下晚下罢了。同样的，ue5没有vs是不行的，rider可没有c编译器和c++开发环境，所以vs该下还是要下。因为有了rider，那么如何不下载vs的编辑器，最轻量的进行UE5开发呢。",
    "tags": [
      "Ue5",
      "Rider",
      "Vs2022",
      "C++",
      "开发环境",
      "游戏开发",
      "C++ Build Tools",
      "C++ Cmake Tools for Windows"
    ],
    "title": "用最轻量的VS负载进行UE5开发(使用rider)",
    "uri": "/hugo-theme-relearn/exampleSite/game/ue5-rider-vs/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking",
    "content": "原文 不知不觉已经结束了，仿佛还是昨天。横观四年，是我认知产生分水岭的四年，纵观四年，跌跌撞撞寻寻觅觅无花结果的四年。 好像一个费力杠杆，拖长了距离，抛足了目光，但是在最后才卯足了劲。实际上，越濒临大学生活的结束，我的经验、体会和技能越集中修成。因为要脱离学生的身份，认知就会指数级的增长。知道的越多越折磨，留下的精神痕迹越多。也尝试修改过，但是学生的值变为false已是现实。\n如果说大学学到什么，我无法笼统回答，我感谢学校给我的所有契机。学习一个东西，三个月和三年三十年效率差不了多少，但是如果是三周三天甚至三小时，那可能是难以想象的高效，水到渠成后也会有更大的成就感。学习了，理解了，来龙去脉摸明了，时间一摇摆，已经生疏了。我从小就对电子设备感兴趣，具体的说是对软件的内容，兴趣驱动我走上了hello world的道路。但实际上，我大学才初次接触编程，初次了解各类编程语言，初次见到软件背后的复杂和行业的水生火热，一切并没有的我大脑中构想的自由。\n我大一初学了python，后面逐渐接触了java，c#，golang，也渐渐对web感兴趣，搭建了自己的网站，做了一些服务器开发。go算是我的主力语言(有几个相关项目在做),python也在我的各种比赛上给了我重要的支持。我也做过一段时间的游戏开发，没有悬念的用了一段时间unity。这都算我的摸索，我应该早些找到团队的，只是我起步太晚了。我认识了很多大一大二的学生，甚至高中生，有思路和编码效率的太多，也许起步早晚根本不是关键，哈哈。\n感谢欧阳老师对本论文的指导，也感谢老师对我docker学习的驱动。对于docker，我很久之前就有使用过，但是没有学习的动机，即使做了后端项目，也没有实际生产环境需要docker部署。在论文的代码的部署上，在我才开始提笔的时候对于docker的理解只限于是名词和如何启动，但是落笔于此时已经对docker拉取上传，内部挂载执行，镜像容器卷管理等等docker常用功能有了实际的运用和理解。受益匪浅。\n感谢copilot给我论文代码的思路指导。未来是AI的时代，我们见证火车的诞生，见证拉车的消亡。\n感谢父母对我的所有正面行动的支持，感谢我所有的朋友和一路走来所有的游戏，所有的动画，在我郁闷时刻给我第三视角解释自己，在我成就时刻给我满足感。最后也感谢阅读到这里的你。寥寥几笔写完学生的最后一笔。\n补充 所有的事物发生皆是螺旋和交织的，诞生皆有原理，结束早已预定。好吧，我只是为了把临时想到的话记录下来。 我想说的是，促成我论文的还有更多更多因素。比如我使用latex，这都得益于matlab课的陈老师，我也在当时第一次接触到了go语言，机缘巧合。比如我使用ipynb写论文和论文的书写方式，在我参加数模比赛时已经预热过了一次了。比如大一的一个雨天，我在伞下认识了一位计院的老师，可是当年我高数挂了，并无后文，但也促使了我更多了了解了计院的一些活动和信息。\n我感谢的老师说实话一只手就可以数过来，萍水相逢，予我帮助，一批又一载，但不再来，我应该感谢的。\n高中三年加大学2年，我对某些爱好出现了扭曲的变化。我厌恶又不甘心。它曾经像一个限制，约束着行动的界限，但在认知逐渐深入后，这个限制破碎的只剩下搞笑。在图书馆上班的一天的晚上，在刷知乎，认知被文字造成了某些冲击，可能这是异变的初始。感谢这个叫墓天才的用户。随即我阅读了大名鼎鼎的\"末日钟\"理论，哈哈，认知再次被解释。逐渐，我越来越从文化，哲学方面解释各个作品。这是背离初衷的，正好当时玩了素晴日，推波助澜，走上了反叛。实际上，是看到了…好吧，总而言之，是被末日钟说中了，被踩到痛处急得跺脚了，前有民工女友，后有末日钟。可惜的是，我被渡航的幻想时间蒙蔽了心智。揭开它们的面纱，哈哈，不拔高一个维度解释他们(从文化，文学等方面)，我无法接受。彷佛是某种欺骗，我应该断然接受的。\n大学中，我的活动主要集中到了游戏方面，也成了小黑盒的常驻用户，就是不在上面买游戏罢了。今天一看，5000多h了。猎杀对决立大功。我从凯尔姆汗出发，寻找丁香与醋栗，寻找🗡与魔法，到达天际镇，到达黄金树，到达传火祭祀场。我从现代武器溯源，从道德与法治5回到上个世纪，在圣丹尼斯大闹一笔，在鼠疫和黑死病的年代成为潜行高手，成为瘟疫传说。然后在一战二战的战场成为萨尼铁塔，成为普通炮灰。我从2D格斗延续游戏厅的热血，从bbcf到骑空士到残忍终结。在仁王和卧龙看光荣魔改历史，在无主大地看2K的疯癫演出，在末日废土看横尾太郎的太刀剧情。刀枪剑戟摩托车，炼金种地恶魔城，从act到休闲，这一切都是不可多得的时光。\n在我还没有认知迸裂时，黄油也是我不可避谈的经历，正因为如此，我对环境厌恶又不甘，大量的黄油的经历，也使我理解更多丑陋。人类需要大清洗，然后进入大乱交时代也是我在无望后发出的义愤疯言。实际上，我身边的人都是接受畸形现实的，不得不接受是这样的，有一天我突然理解，为什么反派像就像古往今来的反派一样渴求力量，因为力量真的有用，祖国人没有剧本限制才是真祖国人。\n致谢也不一定非要罗列感谢，但是唯独最好，没忘记感谢自己，写下无聊的文字聊以自慰。",
    "description": "为了论文篇幅完整性和一些私人性，我的毕业致谢并不完整，我在此做些补充",
    "tags": [],
    "title": "毕业致谢!",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/graduation-thanks/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "dockers报错：Starting MySQL database server mysqld ...failed 进入容器内部，查看mysql错误日志：cat /var/log/mysql/error.log mysql具体报错：Different lower_case_table_names settings for server ('2') and data dictionary ('0'). 出现该问题的重要前提是：\ndocker启动mysql并不是根据官方mysql镜像，而是在一个基础php镜像上安装的mysql服务。 我的mysql数据通过docker的卷挂载在外部，通过一个mysql文件夹管理。 当我把linux上可以运行的镜像和mysql外部卷都发送给win机器运行，由于mysql数据是外部挂载的，所以会出现同一个镜像，换了操作系统却无法运行的问题。本质上是mysql在linux和win上的环境变量lower_case_table_names默认值不同导致的。由于数据库数据在linux上初始化，该值已经为0，而在win上需要为2，所以报错。\nDocker镜像确实是操作系统无关的，但是MySQL的lower_case_table_names设置是与操作系统有关的。这是因为lower_case_table_names设置决定了MySQL如何存储和比较表名和数据库名。\n在Windows和Mac系统中，文件系统通常不区分大小写，因此MySQL默认将lower_case_table_names设置为2。在这种设置下，MySQL将表名存储为小写，并且比较时不区分大小写。\n在Linux系统中，文件系统通常区分大小写，因此MySQL默认将lower_case_table_names设置为0。在这种设置下，MySQL将表名存储为给定的大小写，并且比较时区分大小写。\n当你在一个系统（例如Windows）上创建MySQL数据，然后尝试在另一个系统（例如Linux）上使用这些数据时，可能会出现这个错误。这是因为数据字典（存储了表名和数据库名的元数据）的lower_case_table_names设置与服务器的设置不一致。\n解决方案 解决个蛋，一般都是放在linux上运行的，mysql在哪初始化就在哪部署。将镜像和外部卷都放在linux机器上部署就好了。win上报错要启动mysql前修改那个环境变量的值。\n或者有一种麻烦的思路，就是将其mysql服务从一个容器中剥离出来，新开一个容器启动，这样方便设置环境变量。如果要修改一个非mysql基础镜像的mysql环境变量还是比较繁琐的。新开一个容器，用docker-compose启动即可。",
    "description": "dockers报错：Starting MySQL database server mysqld ...failed 进入容器内部，查看mysql错误日志：cat /var/log/mysql/error.log mysql具体报错：Different lower_case_table_names settings for server ('2') and data dictionary ('0').",
    "tags": [
      "Docker",
      "Mysql",
      "Linux",
      "Windows",
      "开发问题"
    ],
    "title": "【开发问题】linux启动docker镜像成功，而win启动该镜像mysql报错",
    "uri": "/hugo-theme-relearn/exampleSite/web/docker-mysql-error/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Docker",
    "uri": "/hugo-theme-relearn/exampleSite/tags/docker/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Linux",
    "uri": "/hugo-theme-relearn/exampleSite/tags/linux/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Mysql",
    "uri": "/hugo-theme-relearn/exampleSite/tags/mysql/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Windows",
    "uri": "/hugo-theme-relearn/exampleSite/tags/windows/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 开发问题",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking",
    "content": "时间表\n南京大学 东南大学 计划和预约 学生证事件 猫抓插件 宫崎骏电影 清明无事，由于经常听陈浩然抱怨aabb，自己也想出去转转，听到家里要去南京的大学看看就立刻动身出发了。\n车票买的迟，清明果然高峰。前一天没太在意，傍晚勉强抢到了票，但是当时也没注意是杭州西站的，第二天起床稍微晚了 分钟，看着时间也知道不够了，想方设法也没法。去东站是不可能有票了，就改签到了迟一点的西站，勉勉强强搞到一张站票。\n西站是杭州新建的高铁站，在外面和里面看都比较气派，东站已经很好了，但是新盖的还是更胜一筹，很感叹现代化的建设和创造力。车站里面有一种香槟色那样的背景一样，各个检票口做成了气泡装的奇异突起。西站毕竟不是热门站点，人还是少一点，很快就上了高铁。\n由于是站票，我无处安放双腿。二等座车厢都比较拥挤，我在车厢中一直窜梭，找到一等座的车厢总算空旷些，就在那停留了。感觉一等座也没多大区别，无非就是变宽敞了，然后会有随赠食物。\n站的过程还是比较煎熬的，好在到了南京南地铁还是有座位可以歇息。通告了爸妈在哪接头碰面，会合的时候已经下午1点了。\n上午他们自己去了南京大学的鼓楼校区，因为是老校区，也没有什么壮观或者华丽之处，并无多少言语描述。下午准备去仙林校区看看，说是现代化一点。\n但是实际上仙林是在山中，开车去的，但也明显感受到这里交通并不便捷，并且附近没有商场，午饭还要想着在他们学校解决。\n可能清明放假，有不少学校组织学生来南大参观，在仙林碰到了不少学生团队。多来大学看看好啊，没有人天生就上过大学，看看大学的样子，就像是有一层对未来的铺垫。高中认知是封闭的，在突然认知爆开的时候，有了铺垫肯定会好接受很多。\n仙林校区也乏善可陈，南大因为文科是强势方向，陈浩然以后应该并无交集。江苏就两个学校能入他法眼，南大和东南，南大估计这次给他印象并无深刻处，已经pass了。而且由于他先前去过浙大，有了对比，南大更是看不到亮点了。\n东南第二天去的，计划赶不上变化，东南是没有开放的，第二天并没有去成，随即改成了去中山陵。\n在去中山陵的路上我才知道，其实中山陵就在钟山上，而钟山又叫紫金山，高考毕业那年来爬过，汗湿的味道和缆车以及10元可乐的地方。但是中山陵这个方向是没有台阶的，都做成了路，慢慢走上去。在中山陵外停车，要步行三公里才能正式算进入中山陵。有孙中山先生的墓，后面几百台阶之上是孙中山的巨大雕像。人山人海，在爬上最高台阶一览众山小的时候还是很舒畅的。\n只去了免费景点，听袁立州说总统府建议去看看，实际上跑完了中山陵已经累完了：因为全程走，没有载具，走好几公里是很累的。观光车和自行车都在犹豫中否决了。另一方面，我也不想去什么付费景点，既来自，则来之目的实现之。只是看一眼，体验一次，知道什么是什么。\n下中山陵后我就踏入归途了。上了高铁插上耳机，所幸是靠窗作为，听歌看看真是不可多得的惬意时刻。然后好景不长，之后被乘务员叫住，让我初始学生证验证学生资质。我一时语塞，系统是有我的学生信息的，但我确实没有带实体证件，出门只带了手机。乘务员一定要原件确认，很是顽固，手机的照片不给认同。我最后无奈下只能补完全票，这一搞，完全搞乱了心情，很是郁闷。\n到站了后就计划了今天最后一个行程：看宫崎骏的最新电影：你想活出怎样的人生。 我以为是记述性的奇幻故事，实际上是严肃的历史动画，处处都是历史隐喻，了解日本近代史的才会有更深的理解。其中的父亲是日本的军国主义形象，母亲则是象征着日本国，男主自然是当今日本青年，或者说宫崎骏带入的自身角色。以为男主娶了姐妹，实际上是新旧日本，但都是被军官象征的父亲所单承。 鹦鹉自然是美国，醍醐的话目前还没有理解。电影是真的难懂，没有一点合家欢元素，作为影院电影我觉得是不够出色的，但是作为一部电影来说，是可以说说论论的，毕竟他探讨的是严肃的历史话题，背景音乐也笼罩在一种庄重的气氛中，活跃的地方很少。 宫崎骏实际上在劝导日本人正视历史，承认罪行，并且对美国进行了讽刺，这也是宫崎骏反战思想的体现。 宫崎骏作品的火和在中国的广受喜爱，这并不是一件喜闻乐见的事，因为这样在给日本变相的美化，至少有人在反思，至少如何如何有价值观和我们相合的人。 但是实际上，我觉得教科书都没有的东西，很难在日本深入人心。希望我们不是单方面的被影视文化改变了刻板印象。\n看完有点感触，但不多，随后便到了寝室，开始了开始无数次的生活。\n机不可失失不再来，此刻刻不容缓。 刻来，也许是一个不错的名字。我在去宝龙的路上随意的想到。",
    "description": "2024年清明节的记事",
    "tags": [],
    "title": "清明记事",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/qingming_2024/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Agones",
    "uri": "/hugo-theme-relearn/exampleSite/tags/agones/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: K8S",
    "uri": "/hugo-theme-relearn/exampleSite/tags/k8s/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Kubernetes",
    "uri": "/hugo-theme-relearn/exampleSite/tags/kubernetes/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 云原生",
    "uri": "/hugo-theme-relearn/exampleSite/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "学一个新事物从底层理论学肯定是最系统的，但不是最工程的。对于K8S，我个人认为相比苦苦理解各种集群，节点，pods等等概念，不如实际上手一次，从实践上逐步理解理论，自顶向下才是最快最高效的学习模式，因为目的是使用K8S，是工程化，而不是了解k8s架构，设计云云。\n本文基本从0开始部署Agones，进而逐步理解docker，理解K8S。\n相信如果你能发现本文，自然了解Agones是什么，如果不知道自行了解下，不做多介绍，引用官方介绍：\nAgones 是一个开源平台，用于部署、托管、扩展和编排专用游戏服务器，用于大型多人游戏，构建在行业标准的分布式系统平台 Kubernetes 之上。\n部署Agones只是一个任务性的引子，重点还是K8S.\n准备工作 安装docker-desktop 由于我是win机器，在一切之前，得介绍下开发环境，但很简单。 首先得安装docker，注意如下：\n打开任务管理器，看看cpu有没有开启虚拟化，没有则在bios设置中开启。(必要) 安装wsl，无需开启hyper-v,所以家庭还是专业版的windows没啥影响。 自备代理工具，docker官网需要魔法。 安装完docker基本就完成了。\n由于是个人开发测试用，只用部署一个单节点集群就好了，而这在docker-desktop中已经集成了，很方便，如下所示，打开即可：\nkubectl get nodes 如果返回类似 Ready 状态的节点，说明 Kubernetes 已经启动成功。\n注意 ❌：Docker Desktop 的 Kubernetes 只能运行在单个节点上，不适用于生产环境的高可用集群。\nvscode的K8S插件 安装桌面版的docker是有图形化界面的，很直观，但K8S目前我们是没有GUI的，需要吗？并不一定，使用gui会更多的限制你。 Kubernetes 本身主要是通过 kubectl 命令行工具和 YAML 配置文件进行管理的。\n虽然有 kubernetes-dashboard，但别着急，在vscode的插件也有gui可以打开dashboard。推荐安装docker和k8s插件，在vscode中集成开发，然后我逐步解释下插件中每个显示项的作用，从这里就开始理解如何使用K8S辣\nNamespace（命名空间）Kubernetes 内部的逻辑隔离单位，用于划分不同的应用、环境或团队。一个集群可以包含多个 Namespace，每个 Namespace 内的资源相互独立。 Workloads（工作负载）管理 Kubernetes 里运行的应用程序，本质上就是 运行 Pod 的控制器。Workload 负责定义应用如何部署、扩缩容、更新和运行。 Network（网络） 负责 Kubernetes Pod 之间、Pod 和外部系统之间的通信。管理 Service、Ingress、Network Policy 这些 K8s 网络资源。 Storage（存储）管理 Kubernetes 里的持久化存储，确保 Pod 重新启动后数据不会丢失。Volume 只在 Pod 生命周期内有效，但 PersistentVolume（PV）可持久存储数据。 Configuration（配置管理）管理应用的配置信息、环境变量、Secrets（敏感信息）。让应用和环境解耦，比如可以在不修改代码的情况下更改应用配置。 Custom Resource（自定义资源）扩展 Kubernetes，增加新的资源类型，比如 Agones 添加了 GameServer 资源。允许你 创建自己的 K8s API，以适配特定的业务需求。 Helm Releases（Helm 版本管理）管理 Helm 安装的应用（比如 agones）。Helm 是 Kubernetes 的包管理工具，可以一键安装、更新、删除复杂应用。 但Docker Desktop 不包含K8S的包管理工具 Helm 但安装了K8S插件会自动提示下载 kubectl和 helm，前者是命令行操作工具。都是编译好的exe。如果需要可以配到环境变量中，位置在 .../user/.vs-kubernetes下\n提出疑问-区别概念 好了，在部署之前，安装了上文所说的插件，如果刚入门K8S，难免有一些疑问，下面我着重进行些概念补充，希望下面可以顺利进行~\nKubernetes 中 Node 和 Pod 的关系 Node（节点）就是机器，它可以是：物理机（裸机服务器），虚拟机（云服务器、Docker Desktop 里的虚拟 K8s 节点），你的本机（如果你用 Docker Desktop Kubernetes）\nPod（Pod 是容器的封装单位），Pod 运行在 Node上，一个Pod 里面可以有一个或多个容器，Pod共享存储（Volume）、网络（IP 地址）等，K8s 只管理 Pod，不直接管理容器\n如果 Kubernetes 是一个数据中心：\nNode = 一台服务器 Pod = 服务器上的一个应用进程组（可能包含多个容器） 容器 = 运行的进程（比如 Nginx、MySQL 等） 现实中，一个项目是不是只要一个k8s集群就够了？ YES！一个 Kubernetes 集群足够应付绝大部分的项目需求，包括扩展、弹性、资源管理和容器的自动化部署。\n一个K8S集群中会有很多nodes，这些nodes就是物理上的机器，可以有很多个，每个nodes里有很多pods，pods才是实际的部署的应用。nodes已经完成了分布式，多集群可能确实在大型复杂项目的跨地区部署中用到，但咱可以不用了解\n命名空间和nodes有什么区别，为什么有了nodes还需要namespace Nodes（节点） 物理或虚拟机，负责运行 Pod 实际的计算资源（CPU、内存、存储） Namespace（命名空间） 逻辑隔离的环境，管理不同的 K8s 资源 逻辑上的组织单位，不影响物理资源分配 可以把 Node 理解为 “真实的服务器”，而 Namespace 更像是 “应用的文件夹或项目空间” 安装Agones 好了，终于来到重点也不算是重点的部分了。\n但并不重要，因为你可以根据官方文档逐步操作 根据agones官方文档，安装可以通过yaml文件，也可以通过helm包管理安装。\n我是用kubectl命令行拉取的yaml文件完成的安装\nkubectl create namespace agones-system kubectl apply --server-side -f https://raw.githubusercontent.com/googleforgames/agones/release-1.48.0/install/yaml/install.yaml 然后你就可以在 Custom Resource中发现拉去下来的服务了！\n接下来按照官方文档操作进行部署了，并不赘述，因为本文不是介绍怎么部署agones。\n本人使用rider及其K8S插件，在游戏开发的时候进行服务器集群控制的。记住命令行得到pod的ip和端口，接下来就是网络通信的知识了。如果要在unity中和部署的服务器应用通信，自写和后端的通信协议，Agones只是个后台应用调度工具，不涉及和前端交互。\n注意 ❌ Agones Unity SDK 适用于 服务器端（GameServer） 的 Unity 进程而不是前端！\n例如：你用 Unity 制作了一款 服务器端模拟的游戏逻辑，需要让 Agones 调度这个服务器。或者你的游戏服务器是 Unity 编写的，想要与 Agones 交互来管理它的生命周期。但是，如果你想让 Unity 客户端 连接到 GameServer，那 Unity SDK 并不需要。客户端应该直接用 WebSocket、TCP、UDP、HTTP 连接 GameServer。\n结束 怎么就结束了？ 因为从安装agones敲下一行命令行开始，已经完成了一次K8S的体验，只要了解从0到启动一个K8S单节点集群的全过程每个操作的意义，那么恭喜你，已经入门K8S了，就这么简单，剩下的内容需要在一次次部署应用，一次次开关容器中不断积累吧。这不是整体图看这个概念那个概念是什么意思可以解决的。\n怎么用kubectl操作，怎么用helm包管理，这就是启动K8S后亟待解决的唯二的问题，在实践中结束吧！\n如果你有任何疑问，都可以评论联系我~",
    "description": "学一个新事物从底层理论学肯定是最系统的，但不是最工程的。对于K8S，我个人认为相比苦苦理解各种集群，节点，pods等等概念，不如实际上手一次，从实践上逐步理解理论，自顶向下才是最快最高效的学习模式，因为目的是使用K8S，是工程化，而不是了解k8s架构，设计云云。",
    "tags": [
      "K8S",
      "Docker",
      "Agones",
      "Kubernetes",
      "云原生"
    ],
    "title": "自顶向下学习K8S--部署Agones",
    "uri": "/hugo-theme-relearn/exampleSite/web/k8s-agones/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: GRPC",
    "uri": "/hugo-theme-relearn/exampleSite/tags/grpc/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Grpc-Go",
    "uri": "/hugo-theme-relearn/exampleSite/tags/grpc-go/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Grpc-Php",
    "uri": "/hugo-theme-relearn/exampleSite/tags/grpc-php/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Grpc-Python",
    "uri": "/hugo-theme-relearn/exampleSite/tags/grpc-python/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Php",
    "uri": "/hugo-theme-relearn/exampleSite/tags/php/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "grpc是面对微服务框架而风生水起的，上次我用python编写了一个图神经网络处理的微服务，使用grpc放在我的服务器本地端口上。\n现在我希望我的一个php项目也可以调用该服务，现在来试一试吧~\n流程 php的服务器安装protoc php的服务器安装grpc 编写服务端代码 编写客户端代码 由于服务端(python)的代码已经编写或者说已经部署，就不做叙述了。\n安装代码请根据自己的php版本和grpc版本酌情自定义。本人使用的php8.0，grpc1.62.0，protobuf4.62.0\n安装protoc解释器 和windows开发一样，使用grpc服务均需要使用protoc解释器，去官方github下的release下载linux版本： protoc-26.0-linux-x86_64.zip\n解压到 /usr/bin/目录下\n如果你使用宝塔，你也可以直接先在本地电脑上解压，把解压后的bin文件夹里的protoc文件上传到 /usr/bin/中就好了。\n终端中输入 protoc,有返回即为成功\n安装grpc 无论你服务器是否安装pecl，可以直接通过http请求安装php相关包，但是必须安装了php(废话)\n# 下载解压 grpc cd ~ wget http://pecl.php.net/get/grpc-1.62.0.tgz tar xvf grpc-1.62.0.tgz cd grpc-1.62.0 # 生成配置并编译安装(编译安装时间很长，我大概安装了一小时左右) # 注意选择你自己的路径以及php版本，我是80 /www/server/php/80/bin/phpize ./configure --with-php-config=/www/server/php/80/bin/php-config make \u0026\u0026 make install 之后要配置php的拓展 注意，这是必要的，compose安装的grpc依赖，底层还是调用的这个grpc拓展！\n# 配置PHP扩展 cd grpc-1.62.0 echo \"extension = grpc.so\" \u003e\u003e /www/server/php/80/etc/php.ini cd protobuf-4.62.0 # 如果没有路径请仿照grpc安装的方式手动安装安装一下，我个人觉得可能并不需要 echo \"extension = protobuf.so\" \u003e\u003e /www/server/php/80/etc/php.ini 最后重启一下php和nginx服务就大功告成了\n编译protoc文件 具体的protoc文件的定义详细见我之前的博客\n需要安装protoc和grpc_php_plugin\n使用如下代码生成：\nprotoc --php_out ./ you-file.proto #需要安装protoc解释器，生成protoc的php定义文件在当前目录(./) protoc --grpc_out ./ you-file.proto #需要grpc_php_plugin插件安装，生成grpc文件在当前目录 第一行生成你的proto数据定义文件，我生成了 GCNResult.php,Node.php,Edge.php,GraphData.php, 同时还会生成一个GPBMetaData文件夹。 第二行生成php的grpc文件：GCNServiceClient.php\n注意，如果你没有生成grpc文件的插件(安装grpc出现问题)，可以直接下载该插件 然后通过如下代码生成 xxxClient.php文件\nprotoc --grpc_out ./ --plugin=protoc-gen-grpc=/your-path-to-plugin/grpc_php_plugin you-filename.proto :: 自用 :: protoc --grpc_out ./ --plugin=protoc-gen-grpc=/opt/share/grpc_php_plugin gcn.proto 编写php请求的代码(客户端代码) 编写文件前置注意事项 注意：如果你使用宝塔，需要把php设置里的禁用函数 putenv和 proc_open给删除，不然composer安装无法进行。 需要编写composer.json文件，因为使用了 dirname(__FILE__).'/vendor/autoload.php'该自动导入功能。json文件内容示例： { \"require\": { \"grpc/grpc\": \"*\", \"google/protobuf\": \"*\" }, \"autoload\": { \"psr-4\": { \"GPBMetadata\\\\\": \"protoc/GPBMetadata/\", \"protoc\\\\\": \"protoc/\" } } } 编写后在服务器该文件目录下启动终端输入 composer install即可，会生成vendor文件夹\n现在我将编写一个最简单的php文件来调用这个服务。\n\u003c?php require dirname(__FILE__).'/vendor/autoload.php'; // 引入 gRPC PHP 扩展的自动加载文件 require 'protoc/GraphData.php'; // 引入包含 protoc文件夹下的grpc生成文件 require 'protoc/Node.php'; require 'protoc/Edge.php'; require 'protoc/GCNResult.php'; require 'protoc/GCNServiceClient.php'; // 进行grpc请求，获取gcn处理后的数据，返回json字符串 function GCN_request() { $client = new GCNServiceClient('localhost:9999', [ 'credentials' =\u003e \\Grpc\\ChannelCredentials::createInsecure(), ]); // 创建一个实例的图数据 $G_example = new GraphData(); $G_example-\u003esetNodes([ (new Node())-\u003esetId(\"node1\")-\u003esetFeatures([0.1, 0.2, 0.3]), (new Node())-\u003esetId(\"node2\")-\u003esetFeatures([0.4, 0.5, 0.6]), ]); $G_example-\u003esetEdges([ (new Edge())-\u003esetSourceId(\"node1\")-\u003esetTargetId(\"node2\"), ]); // 发送请求并接收响应 list($response, $status) = $client-\u003eProcessGraph($G_example)-\u003ewait(); if ($status-\u003ecode !== Grpc\\STATUS_OK) { // gRPC 请求出错 throw new Exception('Error calling grpc server -\u003e ProcessGraph: ' . $status-\u003edetails); exit(1); } // 因为我的返回结果是个map数据类型，php中没有该类型，需要做一个遍历取值，如果是string类型可以直接取。 $NodeScores = []; foreach ($response-\u003egetNodeScores() as $key =\u003e $value) { $NodeScores[$key] = $value; } return json_encode($NodeScores); } 该函数返回一个json数据，想要修改可以使用 json_decode() , 至此，大功告成！\n备注 因为我的protoc文件的返回结果定义为一个map，这是go才有的数据结构，php没有 使用 var_dump($response-\u003egetNodeScores())可以看到这是谷歌grpc核心中定义的一个mapfield object，可以直接像go的map一样，用 $response-\u003egetNodeScores()['xxx']获取值。\n虽然官网显示有ToString()的方法：https://cloud.google.com/dotnet/docs/reference/Google.Protobuf/latest/Google.Protobuf.Collections.MapField-2#Google_Protobuf_Collections_MapField_2_ToString 但是在这里无法使用，所以我只能通过遍历的方式获取所有值存到一个数组里，毕竟map结构本身就不支持一次获取全部，还是要遍历。",
    "description": "grpc是面对微服务框架而风生水起的，上次我用python编写了一个图神经网络处理的微服务，使用grpc放在我的服务器本地端口上。\n现在我希望我的一个php项目也可以调用该服务，现在来试一试吧~",
    "tags": [
      "GRPC",
      "Php",
      "Grpc-Php",
      "Grpc-Python",
      "Grpc-Go"
    ],
    "title": "php使用grpc服务(从0开始，并且包含mapfield文件解释)",
    "uri": "/hugo-theme-relearn/exampleSite/web/grpc-php/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Python",
    "uri": "/hugo-theme-relearn/exampleSite/tags/python/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "grpc前言 gRPC是Google 开发的高性能、开源的远程过程调用（RPC）框架， 基于 HTTP/2 协议进行通信，使用 Protocol Buffers（protobuf）作为接口定义语言，可以看为一种协议。 grpc可以用于各种不同服务间的通信，屏蔽底层细节(如编程语言，操作系统等)\n由于我的一个go后端(也可以不是go)需要实现神经网络相关的功能，我要调用一个python的服务，于是想到了使用grpc的方式。\n初次接触，将从0介绍到功能实现。\n感谢官方的文档\nhttps://grpc.io/docs/languages/go/quickstart/\n主要流程 定义.proto文件：创建一个 .proto 文件，定义图数据和 GCN 结果的消息类型以及服务接口。 生成 gRPC 代码：使用 Protocol Buffers 编译器 protoc，根据 .proto 文件生成 Go 和 Python 的 gRPC 代码。 实现 Python 服务器：在 Python 中实现 gRPC 服务器，接收来自 Go 客户端的图数据，进行 GCN 处理，并返回处理结果。 实现 Go 客户端：在 Go 中实现 gRPC 客户端，发送图数据到 Python 服务器，并接收处理结果。 安装protoc解释器 grpc是通过pb(protocolbuffer)这个协议工作的，首先安装protoc的解释器，并将其bin文件夹添加到环境变量。 地址：https://github.com/protocolbuffers/protobuf/releases 下载后解压到任意文件夹位置，然后将解压后的bin文件夹添加到环境变量。\n打开cmd输入 protoc有数据返回就ok了。\n为了在项目中使用protoc的一些指令可以正常工作，还有把bin文件下的 protoc.exe文件复制一份到 C:\\Windows\\System32文件夹下。\n顺便一提，为了proto文件可以在vscode高亮显示，可以安装官方的插件：protobuf，作者：pbkit\ngo端工作 首先安装go的grpc库\ngo get -u google.golang.org/grpc 然后安装可以将proto文件自动解析为go文件的解释器：\ngo install google.golang.org/protobuf/cmd/protoc-gen-go go install google.golang.org/grpc/cmd/protoc-gen-go-grpc 定义proto文件 gcn.proto： 其中go_package是指定生成的文件位置和文件所在包名。“.” 表示文件生成在当前目录，“；”表示参数分割，后面的proto是将生成文件放在proto包中。 还有更多可选参数，自行参考官方\ngo_package：指定生成 Go 代码时的包路径，格式为 option go_package = “package_path”;，用于将生成的代码放置在指定的 Go 包中。\njava_package：指定生成 Java 代码时的包路径，格式为 option java_package = “package_path”;，用于将生成的代码放置在指定的 Java 包中。\njava_outer_classname：指定生成 Java 代码时的外部类名，格式为 option java_outer_classname = “ClassName”;，用于指定生成的 Java 类的外部类名。\ncc_generic_services：指定是否生成 C++ 通用服务（generic services），格式为 option cc_generic_services = true; 或 option cc_generic_services = false;，默认为 true。\ncc_enable_arenas：指定是否启用 C++ arenas 内存管理，格式为 option cc_enable_arenas = true; 或 option cc_enable_arenas = false;，默认为 false。\noptimize_for：指定优化选项，可以是 SPEED、CODE_SIZE 或 LITE_RUNTIME，格式为 option optimize_for = SPEED;，默认为 SPEED。\ndeprecated：指定消息或字段已过时，格式为 option deprecated = true;。\nrpc_timeout：指定 gRPC 调用的超时时间，格式为 option rpc_timeout = “10s”;，表示超时时间为 10 秒。\ngcn.proto协议文件具体定义为：\nsyntax = \"proto3\"; option go_package = \".;proto\"; message Node { string id = 1; repeated float features = 2; } message Edge { string source_id = 1; string target_id = 2; } message GraphData { repeated Node nodes = 1; repeated Edge edges = 2; } message GCNResult { map\u003cstring, float\u003e node_scores = 1; } service GCNService { rpc ProcessGraph(GraphData) returns (GCNResult); } 我这里是用来处理图数据。\n接下来生成 gRPC 代码：\nprotoc --go_out=. --go_opt=paths=source_relative your_proto_file.proto protoc --go-grpc_out=. --go-grpc_opt=paths=source_relative your_proto_file.proto 会生成两个文件 gcn.pb.go和 gcn_grpc.pb.go\n前者生成的文件，包含所有pb协议的go代码，将数据格式写为go的结构体形式。包含填充、序列化，检索请求和响应消息类型。 后者包含客户端使用中定义的方法，调用的接口类型。以及服务端要实现的接口类型。包含创建客户端服务和服务端服务的方法。 请注意，无论go后端作为请求grpc的一方(client)还是做出响应的一方(server),这两个文件都是必须生成的。 使用 client := pb.NewXXXXServiceClient(conn)的方式创建客户端 最后就是完成go端的grpc请求代码，每次请求都创建一个grpc的连接，请求完毕defer断开：\nfunc GCN_request() (map[string]float32, error) { conn, err := grpc.Dial(\"localhost:9999\", grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { // Failed to connect to gcnserver(py) by grpc return nil, err } defer conn.Close() client := pb.NewGCNServiceClient(conn) // 创建一个实例的图数据 G_example := \u0026pb.GraphData{ Nodes: []*pb.Node{ {Id: \"node1\", Features: []float32{0.1, 0.2, 0.3}}, {Id: \"node2\", Features: []float32{0.4, 0.5, 0.6}}, }, Edges: []*pb.Edge{ {SourceId: \"node1\", TargetId: \"node2\"}, }, } // 发送请求并接收响应 result, err := client.ProcessGraph(context.Background(), G_example) if err != nil { // Error calling ProcessGraph return nil, err } return result.NodeScores, err } 最后的最后别忘了创建一个路由调用这个方法。\npython端工作 py同样安装grpc相关库\npip install grpcio pip install grpcio-tools 生成grpc文件 终端cd到proto文件目录下，执行：\npython -m grpc_tools.protoc -I ./ --python_out=./ --grpc_python_out=. your-file.proto py的服务端代码grpc相关的代码较为简洁，重点在于数据处理。将其服务端口和grpc客户端的请求端口保持一致。 部分代码取自官方示例。\nimport grpc from concurrent import futures from proto import gcn_pb2_grpc, gcn_pb2 class GCNServicer(gcn_pb2_grpc.GCNServiceServicer): def ProcessGraph(self, request, context): # Process graph data using GCN and return result # example: return gcn_pb2.GCNResult(node_scores={\"node1\": 0.5, \"node2\": 0.8}) def server(): server = grpc.server(futures.ThreadPoolExecutor(max_workers=10)) gcn_pb2_grpc.add_GCNServiceServicer_to_server(GCNServicer(), server) server.add_insecure_port('[::]:9999') server.start() print('gRPC 服务端已开启,端口为9999...') server.wait_for_termination() if __name__ == '__main__': server() 启动 做好了以上工作就大功告成了，启动两个服务即可\ngo run main.go\npython server.py\n然后访问定义的路由地址，如下显示，nice~",
    "description": "gRPC是Google 开发的高性能、开源的远程过程调用（RPC）框架，基于 HTTP/2 协议进行通信，使用 Protocol Buffers（protobuf）作为接口定义语言，可以看为一种协议。grpc可以用于各种不同服务间的通信，屏蔽底层细节(如编程语言，操作系统等)",
    "tags": [
      "GRPC",
      "Go",
      "Python",
      "Grpc-Go",
      "Grpc-Python"
    ],
    "title": "使用grpc在go后端和python服务间通信",
    "uri": "/hugo-theme-relearn/exampleSite/web/grpc-go-python/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "你至少需要启动三个服务\nqsign服务器 go-cqhttp 你自己的机器人后端 gocq只需要启动项目即可，不需要配置域名，qsign和你的后端都需要配置域名 为了可以实现双向通信，你的后端需要实现websocket的通信。\nqsign 从dokcer hub中搜索qsign，按照更新时间排序，找到一个能用的，运行 pull命令。 注意，下载次数最高的镜像无法拉取的，删了跑路了，时间排序到一个有新版本的镜像，低版本的qsign可能会无法登陆。\n如果是通过宝塔部署，在镜像中通过镜像搜索，找到qsign相关镜像无法拉取，都是该镜像跑路了，仓库中不存在，换一个镜像重新拉取即可。\n建议将其部署在国外服务器上。 通过请求qsign服务器，gocq会得到一个token，这个token需要一段时间后刷新，所以需要qsign服务器一直保持活跃。 可以使用docker拉取一个镜像，快速部署,部署后配置域名，get该地址可以获得一个json信息为配置成功。\n注意：最好部署新的版本，如9.0.8，但是docker镜像很多都是镜像只支持老版本，要用新版本需要手动导入新的版本文件，到挂载卷里\n如果你熟悉docker，会最基本的卷挂载，端口映射可以使用： https://hub.docker.com/r/bennettwu/qsign-server 这个镜像的发布者说明也很清楚了，可以不用命令行部署，直接宝塔拉取镜像，创建容器，然后进入容器挂载卷的文件夹内，把9.0.8版本的文件放入，注意，不是文件夹，是覆盖’/app/txlib’内的\n这个镜像较为完整，功能也正常，到docker挂载卷的文件中放入9.0.8版本的qsing文件，同时修改config文件。 config中一点要设置自动注册实例为true，并且设置端口，config中设置的端口将直接影响容器内端口映射是否能正确\n最后这个镜像可以通过：'http://your-site:1145/sign'来访问该qsign服务。 其中，1145是我手动映射到容器的外部端口，/sign是该镜像指明的url访问。\n如果不熟悉docker，可以使用如下镜像一键部署9.0.8版本 https://hub.docker.com/r/woxigousade/qsign\n注意，该镜像在被请求一次后，容器可能会停止，需要自己设置自动重启。同时实例自动注册可能出现问题，原因未知，因为本人熟悉点docker，我已经换上面的那个了。\n部署可以直接参考docker镜像发布者的说明。 通过命令行,镜像run个容器：\ndocker run -d -p 9000:8080 --restart=always --name=qsign -e VERSION=9.0.8 woxigousade/qsign:latest 命令解释：\n服务器9000端口映射容器内8080端口 重启策略设置为\"always\" 创建的容器名为’qsing' 使用版本9.0.8 完成了docker部署，并启动容器之后给该docker部署的镜像设置公网可以访问的域名或者暴露该端口(如9000)直接用端口号访问即可，直接get会有json信息返回，鉴定为部署成功，返回code 0和1都是正常的，主要要看gocq的登录返回信息。\n{ \"code\": 1, \"msg\": \"Parameter 'uin' is missing.\", \"data\": \"failed\" } gocq 拉取gocq项目文件，直接启动一次项目，生成必要的文件 修改协议 填写配置文件 打包部署到服务器 第一步 无要点，下载项目的release版本，或者安装go直接拉项目本地跑\n第二步 建议使用手表协议，device.json改protocol的值为2 将qsign中的config.json文件重命名为6.json，放在项目的 data/versions文件中\n第三步 注意 config.yml文件的填写 只有三个地方是必须要修改的：qq号和密码、qsign服务器地址、服务后端地址(http or ws)\n# go-cqhttp 默认配置文件 account: # 账号相关 uin: your-qq# QQ账号 password: '' # 密码为空时使用扫码登录 encrypt: false # 是否开启密码加密 status: 0 # 在线状态 请参考 https://docs.go-cqhttp.org/guide/config.html#在线状态 relogin: # 重连设置 delay: 3 # 首次重连延迟, 单位秒 interval: 3 # 重连间隔 max-times: 0 # 最大重连次数, 0为无限制 # 是否使用服务器下发的新地址进行重连 # 注意, 此设置可能导致在海外服务器上连接情况更差 use-sso-address: true # 是否允许发送临时会话消息 allow-temp-session: false # 数据包的签名服务器列表，第一个作为主签名服务器，后续作为备用 # 兼容 https://github.com/fuqiuluo/unidbg-fetch-qsign # 如果遇到 登录 45 错误, 或者发送信息风控的话需要填入一个或多个服务器 # 不建议设置过多，设置主备各一个即可，超过 5 个只会取前五个 # 示例: # sign-servers: # - url: 'http://127.0.0.1:8080' # 本地签名服务器 # key: \"114514\" # 相应 key # authorization: \"-\" # authorization 内容, 依服务端设置 # - url: 'https://signserver.example.com' # 线上签名服务器 # key: \"114514\" # authorization: \"-\" # ... # # 服务器可使用docker在本地搭建或者使用他人开放的服务 sign-servers: - url: 'your-qsign-site' # 主签名服务器地址， 必填 key: '114514' # 签名服务器所需要的apikey, 如果签名服务器的版本在1.1.0及以下则此项无效 authorization: '-' # authorization 内容, 依服务端设置，如 'Bearer xxxx' # 判断签名服务不可用（需要切换）的额外规则 # 0: 不设置 （此时仅在请求无法返回结果时判定为不可用） # 1: 在获取到的 sign 为空 （若选此建议关闭 auto-register，一般为实例未注册但是请求签名的情况） # 2: 在获取到的 sign 或 token 为空（若选此建议关闭 auto-refresh-token ） rule-change-sign-server: 1 # 连续寻找可用签名服务器最大尝试次数 # 为 0 时会在连续 3 次没有找到可用签名服务器后保持使用主签名服务器，不再尝试进行切换备用 # 否则会在达到指定次数后 **退出** 主程序 max-check-count: 0 # 签名服务请求超时时间(s) sign-server-timeout: 60 # 如果签名服务器的版本在1.1.0及以下, 请将下面的参数改成true # 建议使用 1.1.6 以上版本，低版本普遍半个月冻结一次 is-below-110: false # 在实例可能丢失（获取到的签名为空）时是否尝试重新注册 # 为 true 时，在签名服务不可用时可能每次发消息都会尝试重新注册并签名。 # 为 false 时，将不会自动注册实例，在签名服务器重启或实例被销毁后需要重启 go-cqhttp 以获取实例 # 否则后续消息将不会正常签名。关闭此项后可以考虑开启签名服务器端 auto_register 避免需要重启 # 由于实现问题，当前建议关闭此项，推荐开启签名服务器的自动注册实例 auto-register: false # 是否在 token 过期后立即自动刷新签名 token（在需要签名时才会检测到，主要防止 token 意外丢失） # 独立于定时刷新 auto-refresh-token: false # 定时刷新 token 间隔时间，单位为分钟, 建议 30~40 分钟, 不可超过 60 分钟 # 目前丢失token也不会有太大影响，可设置为 0 以关闭，推荐开启 refresh-interval: 40 heartbeat: # 心跳频率, 单位秒 # -1 为关闭心跳 interval: 5 message: # 上报数据类型 # 可选: string,array post-format: string # 是否忽略无效的CQ码, 如果为假将原样发送 ignore-invalid-cqcode: false # 是否强制分片发送消息 # 分片发送将会带来更快的速度 # 但是兼容性会有些问题 force-fragment: false # 是否将url分片发送 fix-url: false # 下载图片等请求网络代理 proxy-rewrite: '' # 是否上报自身消息 report-self-message: false # 移除服务端的Reply附带的At remove-reply-at: false # 为Reply附加更多信息 extra-reply-data: false # 跳过 Mime 扫描, 忽略错误数据 skip-mime-scan: false # 是否自动转换 WebP 图片 convert-webp-image: false # download 超时时间(s) http-timeout: 15 output: # 日志等级 trace,debug,info,warn,error log-level: warn # 日志时效 单位天. 超过这个时间之前的日志将会被自动删除. 设置为 0 表示永久保留. log-aging: 15 # 是否在每次启动时强制创建全新的文件储存日志. 为 false 的情况下将会在上次启动时创建的日志文件续写 log-force-new: true # 是否启用日志颜色 log-colorful: true # 是否启用 DEBUG debug: false # 开启调试模式 # 默认中间件锚点 default-middlewares: \u0026default # 访问密钥, 强烈推荐在公网的服务器设置 access-token: '' # 事件过滤器文件目录 filter: '' # API限速设置 # 该设置为全局生效 # 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配 # 目前该限速设置为令牌桶算法, 请参考: # https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin rate-limit: enabled: false # 是否启用限速 frequency: 1 # 令牌回复频率, 单位秒 bucket: 1 # 令牌桶大小 database: # 数据库相关设置 leveldb: # 是否启用内置leveldb数据库 # 启用将会增加10-20MB的内存占用和一定的磁盘空间 # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能 enable: true sqlite3: # 是否启用内置sqlite3数据库 # 启用将会增加一定的内存占用和一定的磁盘空间 # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能 enable: false cachettl: 3600000000000 # 1h # 连接服务列表 servers: # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档 #- http: # http 通信 #- ws: # 正向 Websocket #- ws-reverse: # 反向 Websocket #- pprof: #性能分析服务器 # 反向WS设置 - ws-reverse: # 反向WS Universal 地址 # 注意 设置了此项地址后下面两项将会被忽略 universal: wss://your-site/ws # 反向WS API 地址 api: ws://your_websocket_api.server # 反向WS Event 地址 event: ws://your_websocket_event.server # 重连间隔 单位毫秒 reconnect-interval: 3000 middlewares: \u003c\u003c: *default # 引用默认中间件 第四步 不输入密码，使用扫码登陆。注意先在本地登陆一次，登陆成功后把 data文件夹和 session.token文件上传服务器即可，在服务器端登陆可能会显示登陆风险，要求同一网络。\n后端建设 我用go写的后端 创建ws连接的路由 部署你的后端到国外服务器上/Paas上,将pass提供的地址作为ws地址。",
    "description": "你至少需要启动三个服务\nqsign服务器 go-cqhttp 你自己的机器人后端 gocq只需要启动项目即可，不需要配置域名，qsign和你的后端都需要配置域名 为了可以实现双向通信，你的后端需要实现websocket的通信。",
    "tags": [],
    "title": "基于gocq的qqbot搭建",
    "uri": "/hugo-theme-relearn/exampleSite/project/gocq_based/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: CSS",
    "uri": "/hugo-theme-relearn/exampleSite/tags/css/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Mac风格",
    "uri": "/hugo-theme-relearn/exampleSite/tags/mac%E9%A3%8E%E6%A0%BC/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Prism",
    "uri": "/hugo-theme-relearn/exampleSite/tags/prism/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Typecho",
    "uri": "/hugo-theme-relearn/exampleSite/tags/typecho/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "三步 下载prism文件。 在head中引用，并添加行号类。 修改CSS。 第一步：官网下载，选择语言和需要的插件 易得\n第二步：header.php文件的head块中添加如下代码 \u003c!-- 为pre块添加 line-numbers 类 --\u003e \u003cscript\u003e document.addEventListener('DOMContentLoaded', function () { var codeBlocks = document.querySelectorAll('.post-content pre:not(.line-numbers)'); codeBlocks.forEach(function (codeBlock) { codeBlock.classList.add('line-numbers'); }); }); \u003c/script\u003e \u003c!-- prism 代码高亮\u0026主题选择 --\u003e \u003c!-- 注意prismjs_theme 是我在function文件中定义的 --\u003e \u003c?php if ($this-\u003eoptions-\u003eprismjs_theme == 'tomorrow') : ?\u003e \u003clink rel=\"stylesheet\" href=\"\u003c?php $this-\u003eoptions-\u003ethemeUrl('替换为你的prism.css的路径，下同'); ?\u003e\" /\u003e \u003cscript src=\"\u003c?php $this-\u003eoptions-\u003ethemeUrl('替换为你的prism.js的路径，下同'); ?\u003e\"\u003e\u003c/script\u003e \u003c?php elseif ($this-\u003eoptions-\u003eprismjs_theme == 'coy') : ?\u003e \u003clink rel=\"stylesheet\" href=\"\u003c?php $this-\u003eoptions-\u003ethemeUrl('prismjs/coy/prism.css'); ?\u003e\" /\u003e \u003cscript src=\"\u003c?php $this-\u003eoptions-\u003ethemeUrl('prismjs/coy/prism.js'); ?\u003e\"\u003e\u003c/script\u003e \u003c?php endif; ?\u003e \u003c!-- 修改为mac样式,请替换你的mac.css文件路径--\u003e \u003clink rel=\"stylesheet\" href=\"\u003c?php $this-\u003eoptions-\u003ethemeUrl('css/mac.css'); ?\u003e\" /\u003e 第三步：修改满意的CSS 下面只写了 mac.css文件。 注意，我的效果也修改了下载了 prism.css文件。 更具体的css可以参考我的github仓库，该主题是开源的。\n/* macOS 风格的代码框样式 */ pre[class*=language-] { position: relative; padding: 20px; border-radius: 8px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 20px; transition: box-shadow 0.3s ease-in-out; max-height: 100%; max-width: 85%; padding-top: 50px; } /* macOS 风格的图标 */ pre[class*=language-]::before { content: \"\"; position: absolute; background: url(\"../img/icon_mac.svg\"); background-position-y: center; top: 15px; left: 20px; height: 14px; width: 54px; margin-left: 5px; display: block; } /* 悬浮 */ pre[class*=language-]:hover { box-shadow: 0 25px 15px rgba(0, 0, 0, 0.2); } 你也可以直接从我的仓库拉取源代码！👉👉Ayakin",
    "description": "下载prism文件。在head中引用，并添加行号类。修改CSS。",
    "tags": [
      "Typecho",
      "Prism",
      "Mac风格",
      "CSS"
    ],
    "title": "Typecho中代码高亮并有Mac风格",
    "uri": "/hugo-theme-relearn/exampleSite/web/prism-mac-style/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Telegram",
    "uri": "/hugo-theme-relearn/exampleSite/tags/telegram/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Web",
    "content": "基本示例我放在了github上：Gobot 最终实现效果 👇👇👇 创建bot 从botfather处创建bot，命名为 vio. 明确使用需求和目的，进而选择开发工具和相关库(主要使用go和colly库，tg官方也有go的api库)\n使用HTTPS 在Telegram的Bot API中，使用HTTPS是强烈建议的。如果Bot使用HTTP而不是HTTPS，Telegram服务器可能会拒绝处理请求。 为了确保Tg Bot能够正常运行并保障通信安全，最好使用HTTPS。许多服务提供商都提供免费的SSL证书. 如：Let’s Encrypt证书，它是一种免费的、开源的证书颁发机构（CA），可以用来为服务器启用HTTPS，从而实现安全的Bot通信。\n但是如果部署在paas平台，则无需考虑证书相关的问题，更多部署细节可以查看我 仓库的说明\n响应方式 Telegram Bot有以下响应方式：\n长轮询（Long Polling）： 这是一种常见的实时通信方式。Bot向Telegram服务器发送一个请求，然后服务器一直保持连接打开，直到有新消息到达。这样，Bot能够即时收到用户的消息并立即作出响应。长轮询是一种相对简单的方式，适用于需要实时性的场景。\nWebhook： Webhook是一种更为高效和现代的方式。允许你在你的服务器上设置一个HTTP端点，当有新消息到达时，Telegram服务器会向这个端点发送POST请求。这样，你的Bot可以立即得知有新消息，并作出响应。使用Webhook能够避免频繁的轮询操作，提高效率。\n云函数（Cloud Functions）： 你还可以将Bot的部分功能部署到云函数（如AWS Lambda、Google Cloud Functions等）上，以响应特定的事件。这样可以实现高度的可伸缩性和响应性。\nwebhook 为了有较好的实时通信体验，并且完成多方通信，我准备使用webhook的方案。\n设置Webhook端点： 在我服务器上，创建一个HTTP端点来接收Telegram的Webhook请求。这个端点需要运行在公共网络上，并且能够处理POST请求。这个端点将会接收到所有的Telegram消息。\n配置Bot的Webhook： 使用Telegram Bot API设置Bot的Webhook，指向刚刚创建的HTTP端点。可以使用NewWebhook方法，指定Webhook的URL(我部署在paas平台上，无需使用证书密钥)。\npaas平台部署 我选择了zeabur这个服务提供平台,\nzeabur上项目部署非常快,甚至不用写dockfile,而且对go项目有完整的支持,算是符合他们的口号:\nDeploying your service with one click\n在使用paas服务时，需要注意项目的端口号设置,最好设置在环境变量中,然后在项目中通过 os.Getenv(\"xxx\")来获取端口号.\nzeabur的go项目中，环境变量PORT是默认8080，且为全局的。也可以不设置，直接调用就好了。\n对于tgbot：官方示例中使用的8443端口，在部署到paas平台时8443端口需要确认是否开放。 我建议不要使用官方示例中把端口号写明的写法，通过环境变量PORT调用端口号，避免webhook创建失败，或者监听未开放的端口等问题。 调用chatGPT API 首先获取密钥 但是注意，不是申请了账号密钥就可以使用的，只有三个月内注册的账号每个月有免费的5$的额度。如果没有额度，申请的密钥也是无法使用的。很多购买的GPT的账号，api基本都是没额度或者额度每个月都被其他人用完的，可以使用国内的中转代理，来解决密钥的问题。 我推荐一个：柏拉图次元Al\nGPT代理问题 注意：如果使用中转，需要更换post请求的URL\n使用go-openai库后，需要更改config 更多细节可以查看服务提供商的文档，以及这个issue\n示例：URL：\"https://api.example.com/v1\". 其中后面的“v1”是必须的\n实现数据处理逻辑 对于tgbot来说，私聊要回复信息需要知道user的id或者username，但是在群里中需要知道chat的id。\n注意，tg的群组分为group和supergroup，公开的群组都是supergroup，只有私群是group。\n设置了消息处理逻辑，如果想直接用chatgpt的api来聊天，写一个函数调用就可以了。\n对于go语言来说，有一个以及封装好的，对于openai API使用的库：go-openai\n重新部署 把chatGPT的API密钥写在环境变量中，redeploy服务就好了",
    "description": "从botfather处创建bot，命名为 vio.明确使用需求和目的，进而选择开发工具和相关库(主要使用go和colly库，tg官方也有go的api库)",
    "tags": [
      "Telegram",
      "Bot",
      "Go",
      "Webhook"
    ],
    "title": "Telegram Bot部署",
    "uri": "/hugo-theme-relearn/exampleSite/web/telegram-bot/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: Webhook",
    "uri": "/hugo-theme-relearn/exampleSite/tags/webhook/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "主要使用pyautogui的库实现，以及使用gooey库制作了GUI。 详细请访问我的**github项目页面**\n图像识别旅者\n❗ 免责声明 \u003cbr\u003e本脚本使用后果均为使用者个人承担 \u003cbr\u003eThe consequence of using this script must be undertaken by user. 功能 支持图形化界面 自定义excel和图片路径 使用checkbox选择是否循环和跳过匹配不到的图片 设置菜单，显示关于文本 指令功能 多次匹配不到一个指令可以跳过该指令 可以设置只执行一次的指令 鼠标功能 单击 双击 右键 移动到指定图片的位置 移动到指定屏幕坐标 长按鼠标 长按鼠标拖拽 输入功能 文本输入 键盘按键键入 按键可以长按 等待功能 用户自定义每一步等待时长 滚轮功能 截图功能 截全屏 自定义范围 保存截图，命名为“字母+数字”组合 用户自定义鼠标参数 优化gui界面 优化Excel表，添加了更加准确的数据检查。 使用方法 在commands.xlsx文件中配置每一步的指令，根据表格提示填入对应的内容(你也可以填入数字指令：0123456789，分别具备鼠标拖拽，单击，双击，右键单击，输入，等待，滚动，移动，截图，键盘按键的功能)。 关于重复：对于单一指令的重复，当重复过程中多次匹配失败则会跳出重复，执行下一条指令。 指令文件（commands.xlsx）表格添加了数据验证，方便指令填写。可以存在多个指令文件，每次选择相应的作业去完成。 点击ATRI.py文件运行，最好使用pyw，无黑窗启动。❤ 功能解释 鼠标拖拽[0]:必须指定一个图片参数，使鼠标移动到该图片位置。如果可选参数是数字，进行鼠标长按操作，参数值为长按时间；可选参数为图片名，则进行拖拽操作，拖拽到可选参数的图片位置 左键单击1:鼠标单击 左键双击[2]:鼠标双击 右键单击[3]:鼠标右键单击 输入[4]:输入一段文本 等待[5]:time.sleep() 滚轮[6]:使用滚轮，正值前滚，负值后滚 移动鼠标[7]:移动鼠标到指定的图片位置。如果参数输入的不是图片名而是坐标，类似 [200,300],则会移动到坐标位置。 截图[8]：鼠标点击和移动默认为图片的中心位置，截图的区域指定内容必须类似为 [0,0,200,300]‘的坐标格式，分别代表矩形区域对角线的坐标 键盘按键[9]，默认为立即释放,如果可选参数不为空，则表示长按该按键的时间 效果演示 用户可以根据自定义的指令文件搭配出繁多的操作流程，接下来举例说明如何使用该程序打开浏览器，并输入一行js代码：\n以下是指令表，指令类型数字代码和文字都可以。\n指令类型 参数(图片名称.png、输入内容、等待时长/秒、截图范围) 重复次数(-1代表只运行一次 0代表多次匹配不到可以跳过) 可选参数(图片名称.png、时间/秒） 备注 2 edge.png -1 打开edge浏览器，只运行一次 1 search.png -1 点击搜索栏，只运行一次 4 \u003cwww.baidu.com\u003e -1 输入百度网址，只运行一次 键盘按键 enter 输入回车 键盘按键 F12 -1 进入开发者模式，只运行一次 1 control.png 点击控制台，准备输入代码 4 console.log(“Hello world!”); 输入js代码 键盘按键 enter 输入回车，打印log 8 [200,500,500,800] 区域截图，并保存 9 F5 刷新页面 等待 5 等待5秒，然后循环输入js 每一步的逻辑备注在注释里，这样就可以实现一直输入js，一直截图的效果，当然这只是一个简单的效果，更多复杂的搭配根据指令而异。\n本人也用过作为游戏辅助程序用来挂机刷道具，用处多多，多多开发 😄\n注意事项 文件夹必须放在英文路径下 python版本不要高于3.9，3.9版本改变了xlrd包中部分函数名的使用，在读取xlsx文件会异常。（解决方案：找到xlrd包的位置，打开 xlsx.py文件,查找里面的 getiterator()函数，全部替换成 iter()，保存关闭后即可。） 注意coloerd包的版本，gooey库内用的colored包最高版本为1.4.4，colored包在2023.7进行更新到了2.0，而gooey还未适应。 安装依赖 在项目根目录shift+右键，打开Powershell窗口，执行：\npip install -r requirements.txt 更新日志 v1.5 完善了最后的功能，比如拖拽鼠标，延迟按键等。 优化了excel，指令变为可选下拉栏。 优化了数据检查，为一些不合法参数添加了一些必要说明，比如截图的参数格式等。 丰富了预览文档，图示操作，并添加了一些使用技巧。 因为早期框架构思的不好，如今功能扩充困难，此为最终版本，不再做其他调整。 v1.4 改变了单一指令重复执行的逻辑，如果在重复执行的过程中图片匹配失败10次，则会跳出循环，不再重复，进而执行下一条指令。防止卡壳。\n实现了可以添加只执行一次的指令的功能。\nv1.3 没事做重新捡起来优化一下，改变了gui界面，优化了文件的格式和排布，增加了代码可读性。 同时增加了键盘按键的功能，不过目前只做了按下立即释放的功能，后续会增加长按(延迟释放)的功能。\nv1.2 添加了截图功能，可以自定义截图范围，图片保存的文件夹也可以自定义。 添加了自定义鼠标参数的功能，点击间隔和执行时鼠标移动持续时间，默认均为0.2\nv1.1 改了功能“7”为移动鼠标，判断功能后面再补。\n主要添加了是否循环和匹配不到自动跳过的功能，图片也支持手动输入文件夹检索了。\nv1.0 这是一个基于图片匹配的自动操作脚本，可以实现部分软件操作的自动化。\n我根据gooey库，制作了一个图形化界面，用来调用参数和用户选项。",
    "description": "主要使用pyautogui的库实现，以及使用gooey库制作了GUI。 详细请访问我的**github项目页面**",
    "tags": [],
    "title": "基于pyautogui的自动化程序",
    "uri": "/hugo-theme-relearn/exampleSite/project/atravelerrecognizeimage/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "演示DEMO地址 技术栈：gin+gorm+mysql+jwt+redis+grpc+pytorch+vue3+vite+tailwind 前言 一方面为了完成毕设(毕设大概率是造前人的轮子了)，一方面也是毕设导师要求用WP了，那纯兴趣使然了。 这个项目的开发很是缓慢，因为今年大部分时间在考研，而且前后端技术栈有很多空白，如果类似bangumi这样的网站，数据库的知识也不能缺乏。我coding效率一般，好在有chatgpt的强力支持，bangmui的网站api是开放的，但我可能没精力实现全部功能。我的目标其实是一个纯粹的个人打分网站(去社交化，但提供社交软件导入)\n随着对web开发的认知逐步完善，我决定大改需求，原来的目标推翻重做，造轮子实在比较蠢。\n我是bangumi网站的用户，兴趣之余也想利用本人能力仿制一个功能类似的项目，添加个人认为有必要的其他功能，使用不同于bangumi站点的设计框架，设计一个可以给用户类似使用需求的web应用。\n—–时间线总览—–\n确认了需求和使用什么前后端的框架,今天从0搭建了vue+elementui框架 [2023/9/30] 使用vite+vue3+elements-plus开发前端，之前vue-cil太多是基于vue2的，要做就做新的 [2023/10/10] 没时间搞，今天想了一下看，把需求推翻重做，不是以仿bangumi的web应用为目标，bangui有自己正在开发的react应用，多劳无益，还不如去fork。现在摸清楚了bangumi的api怎么调用，数据怎么get，post，做完一个完成的自助数据查询网站也不错了。没多余精力搞前端，u3d还在水深火热之中[2023/11/16] 决定使用vue3+go的前后端框架，完成了对用户和条目信息的get和分析。 [2023/11/16] 花了两天，做了界面，用weave的界面做了一定的参考，可以想象，css是复杂精密的，界面制作是个细活，还是挺难上手的。完成了功能 查询用户，用户页面，用户页面进行用户收藏查询(一次显示8个，有下一页按钮) 导航，页脚，侧边栏设计 时间线，关于，以及重点的文档页面，通过调用github的api获取仓库的README.md文件 查询条目 [2023/11/27] 实现了前后端基本交互，完善了登陆和注册功能，线上连接了mysql和redis [2024/1/4] 终极完善了登录注册功能，使用了中间件鉴权，jwt的方式，给两种登录方式各设置了不同的token。 [2024/2] 实现了收藏的大部分功能，推荐算法的执行部分使用python编写，部署为一个微服务，通过grpc的方式调用。 [2024/3] bangumi开源项目，相关链接： bangumi API bangmui 用户授权机制\n自助数据检索功能\n在login页面，输入用户名，返回用户相关信息 输入相关条目，返回需要的条目信息 原型设计 参考bangumi各种辅助工具的UI逻辑，但是界面设计可以更现代化一点，可能会花费很多时间，会经济的考虑设计样式。 项目参考：weave\n前端 个人作全栈开发，用vue这种较为轻量的前端开发框架。目前决定使用vue3+element-plus做前端。 框架搭建：下载node.js，配置环境。创建第一个vue单页应用。根据elementUI的官方步骤，搭建框架\n今天发现之前是基于vue2的，用的是vue官方vue-cli脚手架，现在更推荐使用vite，仅支持vue3，遂改之。 elementui也更新为element-plus仅用于支持vue3。vite不用全局安装，较为轻量。有了以前摸索的基础，下载了路由组件和element-plus，迅速就搭建好了空项目。\n花了一下午搞清楚了bangumi的API是怎么在vite中用axios的get和post请求调用的，记录了。输入用户名或者各种搜索条件可以获取到相应的数据了，下一步做一个数据爬取，然后完善功能吧。\n前端基本首页做完了，现在就是功能逻辑了，用户的功能也大差不大了，项目准备build发布一次，后续开发一下检索的功能，并开发后端和数据库，进行数据处理。\n基本完善了99%的页面设计。\n后端 后端用golang编写，使用GIN的框架。 Restful API，使用gorm接入mysql，接入redis。\n目前实现了一个基本的登陆和注册功能，并把用户数据存放到数据库。处理前端POST的数据进行登陆和注册验证。 使用jwt，构造鉴权中间件，分组路由实现。\n数据库中目前只有一个用户表。同时新建了条目表和用户收藏表，用于建立两表之间的联系。 添加了tag表，gorm中用many2many的方式和条目表构建一个关系，同时用于对用户标签化，便于进行推荐算法。\n使用grpc服务和python后端通信。由于神经网络算法的代码过于依赖python，我将其微服务化，可以使得该代码给多个项目使用。通过定义protoc文件，生成protoc文件，编写grpc客户端和服务端代码，算法后端已经成熟的运行了。\n总结 vue基本官方文档就能解决90%的问题，构建后大小也很惊人， 只有几MB。 其实完成了这个，vue的使用倒没有熟练多少，更多是了解了很多前端技术栈的知识，刚起步的时候，连vue和vite是什么都分不清，还一直以为我用的是vite框架呢🤣(导致项目名字也叫digbgm_vite了，笑)\n走完从开发到生产环境部署的全流程，实践一遍可以学到很多以为简单但并没那么简单的事情。比如api的调用跨域(需要nginx使用反代理，把指定的地址反代到跨域的地址)，刷新404问题，都是典中典，新手是这样的\n前端最大的问题，我觉得是配css，这是最折磨的，特别我还有一点强迫，还好我也不是主营前端，css凑合吧… 现在我觉得说不定用tailwind会好一点。。。😥\n后端的搭建基于我对go的逐渐熟练以后，在有了go的相关基础和gin的一定使用经验后，我快速搭建了该项目的后端，并进行了线上部署。go打包后为linux可执行文件，上线是很快的，一键部署。在使用配置文件启动项目后，也更加了灵活。",
    "description": "演示DEMO地址 技术栈：gin+gorm+mysql+jwt+redis+grpc+pytorch+vue3+vite+tailwind",
    "tags": [],
    "title": "FavAni--从0开始的web开发日志",
    "uri": "/hugo-theme-relearn/exampleSite/project/favani/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "实际上Bwiki有现成的赛马娘抽卡模拟，用pyqt有参照实现更容易了： Bwiki赛马娘抽卡模拟器\n预览 功能实现\n单抽+十连的结果图片显示 十连保底出现SR 重做界面，删除无用的登陆界面 可以抽取马娘池，也可以抽取支援卡池子 对抽卡结果的统计 可以自主选择卡池 选择不同卡池出现不同的标志性图片 显示公告 建立抽卡模拟器的数据库，建立表：卡池表，卡牌表，卡池\u0026卡牌表，抽取结果表 连接数据库 显示抽卡记录的日志 项目结构： QT界面预览： QT控件表： 程序界面预览： 运行展示 由于我展示还没有创建卡牌的数据库，我只根据星级给抽卡结果进行了分类，从数据库中查找卡牌的各种信息更符合实际（但卡牌数据的构建实在过于麻烦，遂先不搞）。所以结果我做的只有外框显示就行了 具体实现 同样，我们需要将UI文件和启动的py文件分离。通过QTdesigner设计的界面，在vscode的qt插件中右键，选中“PYQT:Compile Form”,自动生成ui的py文件，之后新建一个启动器文件。这样的好处在于可以随时改变界面。 创建一个res文件夹存放图片文件，一个data文件夹存放数据文件。\nstart.py的源码：\nimport sys import random #PyQt5中使用的基本控件 from PyQt5.QtWidgets import QApplication, QMainWindow,QMessageBox from PyQt5.QtGui import QPixmap #导入designer界面 from Ui_抽卡系统 import* class MyMainForm(QMainWindow, Ui_Form): def __init__(self, parent=None): super(MyMainForm, self).__init__(parent) self.setupUi(self) #提供标题 self.setWindowTitle(\"抽卡模拟器\") #添加信号和槽。 self.change_cardpool.clicked.connect(self.change_pool) self.change_cardpool_2.clicked.connect(self.change_pool_2) self.getone.clicked.connect(self.one) self.getten.clicked.connect(self.ten) self.getone_2.clicked.connect(self.one_2) self.getten_2.clicked.connect(self.ten_2) self.askbutton.clicked.connect(self.ask) # 加载并显示默认图片 image_path = \"res/2.5th Anniversary卡池.png\" #默认出现的图片 self.load_image(image_path) image_path = \"res/2.5th Anniversary支援卡池.png\" #默认出现的图片 self.load_image_2(image_path) 加载图片，参数设置一个图片的路径\n#马池图 def load_image(self,image_path): pixmap = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 self.view_pool.setPixmap(pixmap) self.view_pool.setScaledContents(True) #支援卡池图 def load_image_2(self,image_path): pixmap_2 = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 self.view_pool_2.setPixmap(pixmap_2) self.view_pool_2.setScaledContents(True) 定义改变卡池的函数\ndef change_pool(self): cardpool_name=self.cardpool_Box.currentText() #读取卡池信息 self.label_cardpool.setText(cardpool_name) image_path = \"res/\"+cardpool_name+\".png\" self.load_image(image_path) def change_pool_2(self): cardpool_name=self.cardpool_Box_2.currentText() #读取卡池信息 self.label_cardpool_2.setText(cardpool_name) image_path = \"res/\"+cardpool_name+\".png\" self.load_image_2(image_path) 池单抽和十连函数的实现\ndef one(self): #清空十连的显示结果 self.labels = [self.label_1, self.label_2, self.label_3, self.label_4, self.label_5, self.label_6, self.label_7, self.label_8, self.label_9, self.label_10] #将标签存放为标签数组 for label in self.labels: label.clear() #获取控件数据 getnum=int(self.value_getnum.text()) ssrnum=int(self.value_ssrnum.text()) srnum=int(self.value_srnum.text()) rnum=int(self.value_rnum.text()) # 定义不同星级卡的概率 star_probabilities = { \"R\": 0.79, \"SR\": 0.18, \"SSR\": 0.03 } # 根据概率随机抽取星级 star = random.choices(list(star_probabilities.keys()), weights=list(star_probabilities.values()), k=1)[0] #显示抽卡结果 image_path = \"res/\"+star+\".png\" # 替换为你的图片路径 pixmap = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 self.label_11.setPixmap(pixmap) self.label_11.setScaledContents(True) #更新统计数据 getnum=getnum+1 self.value_getnum.setText(str(getnum)) if (star==\"R\"): rnum=rnum+1 self.value_rnum.setText(str(rnum)) elif(star==\"SR\"): srnum=srnum+1 self.value_srnum.setText(str(srnum)) elif(star==\"SSR\"): ssrnum=ssrnum+1 self.value_ssrnum.setText(str(ssrnum)) self.value_Pssr.setText(str(round(ssrnum*100/(getnum),2))+\"%\") def ten(self): #单抽结果置为空 self.label_11.clear() #获取控件数据 getnum=int(self.value_getnum.text()) ssrnum=int(self.value_ssrnum.text()) srnum=int(self.value_srnum.text()) rnum=int(self.value_rnum.text()) # 定义不同星级卡的概率 star_probabilities = { \"R\": 0.79, \"SR\": 0.18, \"SSR\": 0.03 } # 确保至少出现一张SR卡,具体实现为没有SR卡就循环重抽 while True: cards_star = [] for _ in range(10): rand_num = random.random() # 生成0到1之间的随机数 card_type = None # 根据随机数和概率判断抽到的卡牌类型 if rand_num \u003c star_probabilities['SSR']: card_type = 'SSR' elif rand_num \u003c star_probabilities['SSR'] + star_probabilities['SR']: card_type = 'SR' else: card_type = 'R' cards_star.append(card_type) if 'SR' in cards_star: break #将十张卡内容展现出来，并计算抽卡结果的计数 self.labels = [self.label_1, self.label_2, self.label_3, self.label_4, self.label_5, self.label_6, self.label_7, self.label_8, self.label_9, self.label_10] #将标签存放为标签数组 for label in self.labels: i=self.labels.index(label) image_path = \"res/\"+str(cards_star[i])+\".png\" # 替换为你的图片路径 pixmap = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 label.setPixmap(pixmap) label.setScaledContents(True) #同时更新计数器 if (cards_star[i]==\"R\"): rnum=rnum+1 elif(cards_star[i]==\"SR\"): srnum=srnum+1 elif(cards_star[i]==\"SSR\"): ssrnum=ssrnum+1 #更新统计数据 getnum=getnum+10 self.value_getnum.setText(str(getnum)) self.value_rnum.setText(str(rnum)) self.value_srnum.setText(str(srnum)) self.value_ssrnum.setText(str(ssrnum)) self.value_Pssr.setText(str(round(ssrnum*100/(getnum),2))+\"%\") 接下来定义抽卡的函数，实现单抽和十连\n################# 支援卡池（上两个函数的复制，就是改变了标签名字，xxx-\u003exxx_2） def one_2(self): #清空十连的显示结果 self.labels = [self.label_12, self.label_13, self.label_14, self.label_15, self.label_16, self.label_17, self.label_18, self.label_19, self.label_20, self.label_21] #将标签存放为标签数组 for label in self.labels: label.clear() #获取控件数据 getnum=int(self.value_getnum_3.text()) ssrnum=int(self.value_ssrnum_3.text()) srnum=int(self.value_srnum_2.text()) rnum=int(self.value_rnum_3.text()) # 定义不同星级卡的概率 star_probabilities = { \"R\": 0.79, \"SR\": 0.18, \"SSR\": 0.03 } # 根据概率随机抽取星级 star = random.choices(list(star_probabilities.keys()), weights=list(star_probabilities.values()), k=1)[0] #显示抽卡结果 image_path = \"res/\"+star+\".png\" # 替换为你的图片路径 pixmap = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 self.label_22.setPixmap(pixmap) self.label_22.setScaledContents(True) #更新统计数据 getnum=getnum+1 self.value_getnum_3.setText(str(getnum)) if (star==\"R\"): rnum=rnum+1 self.value_rnum_3.setText(str(rnum)) elif(star==\"SR\"): srnum=srnum+1 self.value_srnum_2.setText(str(srnum)) elif(star==\"SSR\"): ssrnum=ssrnum+1 self.value_ssrnum_3.setText(str(ssrnum)) self.value_Pssr_3.setText(str(round(ssrnum*100/(getnum),2))+\"%\") def ten_2(self): #单抽结果置为空 self.label_22.clear() #获取控件数据 getnum=int(self.value_getnum_3.text()) ssrnum=int(self.value_ssrnum_3.text()) srnum=int(self.value_srnum_2.text()) rnum=int(self.value_rnum_3.text()) # 定义不同星级卡的概率 star_probabilities = { \"R\": 0.79, \"SR\": 0.18, \"SSR\": 0.03 } # 确保至少出现一张SR卡,具体实现为没有SR卡就循环重抽 while True: cards_star = [] for _ in range(10): rand_num = random.random() # 生成0到1之间的随机数 card_type = None # 根据随机数和概率判断抽到的卡牌类型 if rand_num \u003c star_probabilities['SSR']: card_type = 'SSR' elif rand_num \u003c star_probabilities['SSR'] + star_probabilities['SR']: card_type = 'SR' else: card_type = 'R' cards_star.append(card_type) if 'SR' in cards_star: break #将十张卡内容展现出来，并计算抽卡结果的计数 self.labels = [self.label_12, self.label_13, self.label_14, self.label_15, self.label_16, self.label_17, self.label_18, self.label_19, self.label_20, self.label_21] #将标签存放为标签数组 for label in self.labels: i=self.labels.index(label) image_path = \"res/\"+cards_star[i]+\".png\" # 替换为你的图片路径 pixmap = QPixmap(image_path) #变为Qpixmap对象 # 调整 QLabel 大小以适应图片 self.labels[i].setPixmap(pixmap) self.labels[i].setScaledContents(True) #同时更新计数器 if (cards_star[i]==\"R\"): rnum=rnum+1 elif(cards_star[i]==\"SR\"): srnum=srnum+1 elif(cards_star[i]==\"SSR\"): ssrnum=ssrnum+1 #更新统计数据 getnum=getnum+10 self.value_getnum_3.setText(str(getnum)) self.value_rnum_3.setText(str(rnum)) self.value_srnum_2.setText(str(srnum)) self.value_ssrnum_3.setText(str(ssrnum)) self.value_Pssr_3.setText(str(round(ssrnum*100/(getnum),2))+\"%\") 最后写一下公告，并运行\n#定义公告函数 def ask(self): text=open(\"data/公告.txt\").read() QMessageBox.about(self, \"公告内容\", text ) if __name__ == \"__main__\": #固定语句。sys.argv是命令行参数列表，确保程序可以双击运行 app = QApplication(sys.argv) #初始化 myWin = MyMainForm() #将窗口控件显示在屏幕上 myWin.show() #程序运行，sys.exit方法确保程序完整退出。 sys.exit(app.exec_()) 公告还是从txt文件读取，其中很多参数在程序里是写死了的，比如抽卡概率，图片文件位置和名称等，适当更改。\n源码地址 全部源码上传了 GitHub",
    "description": "之前课程设计做过，当时搞得还是挺烂的，PYQT挺好用的，现在基于之前的改进，使得功能更加符合正常的抽卡模拟器需求，同时添加连接数据库。",
    "tags": [],
    "title": "【PYQT】赛马娘抽卡模拟器-基于Bwiki的抽卡模拟(上)",
    "uri": "/hugo-theme-relearn/exampleSite/project/uma_drawcard_1/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Project",
    "content": "前言 本贴将之前没有连接数据库的抽卡模拟器全部完善，最终已经放在了Github上\n用的mysql构建的数据库，导出sql文件，用SQlite3再读一遍，生成一个db文件，创建了四个表\n表 属性 卡池表 序号，卡池名，up角色 卡牌表 卡牌序号，卡牌名，卡牌星级，卡牌种类 卡池\u0026卡牌表 序号，卡池名，卡牌名 抽卡记录表 记录序号，卡池名，卡牌名 简单易用就好，其实后两个表应该用卡池和卡牌表的主键(序号)来做外码的，但查询语句多写一段有点麻烦，就不绕弯子，直接用名字查了。\n预览 功能实现\n单抽+十连的结果图片显示 十连保底出现SR 重做界面，删除无用的登陆界面 可以抽取马娘池，也可以抽取支援卡池子 对抽卡结果的统计 可以自主选择卡池 选择不同卡池出现不同的标志性图片 显示公告 建立抽卡模拟器的数据库，建立表：卡池表，卡牌表，卡池\u0026卡牌表，抽取结果表 连接数据库 抽卡后输出抽卡日志 说明 抽卡逻辑为：\n先得到本次抽卡卡的稀有度 在数据库中查询该稀有度的所有卡牌，随机返回一张 十连保底，但up的概率并未添加 对于日志中的None，表示的是卡名称查询不到。这是因为卡牌数据库构建的不完备，数据太少，有的品质的卡没有具体写入，修改data文件夹中的数据可以完善。data文件夹就是数据库中构建的三个表，而第四个表–抽卡记录表在程序运行后会以txt格式输出到根目录。\n具体修改 为了简明，我把数据库相关的函数写在了conn2sql.py文件中，其中包含数据库的创建，添加元素，查找卡牌以及将数据库的某表输出为txt 源码：\nimport sqlite3 import random # 创建数据库 def create_database_from_sql(sql_file, db_name): with open(sql_file, 'r') as file: sql_statements = file.read() conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.executescript(sql_statements) conn.commit() conn.close() # 数据写入数据库 #添加卡池信息 def insert_cardpool(text_file, db_name): conn = sqlite3.connect(db_name) cursor = conn.cursor() with open(text_file, 'r') as file: lines = file.readlines() for line in lines: pool_no, pool_name,pool_up = line.strip().split(\",\") cursor.execute(\"INSERT INTO card_pool (pool_no,pool_name,pool_up) VALUES (?,?,?)\", (pool_no, pool_name,pool_up)) conn.commit() conn.close() #添加卡牌信息 def insert_card(text_file, db_name): conn = sqlite3.connect(db_name) cursor = conn.cursor() with open(text_file, 'r') as file: lines = file.readlines() for line in lines: card_no, card_name,card_kind,card_star= line.strip().split(\",\") cursor.execute(\"INSERT INTO card (card_no, card_name,card_kind,card_star) VALUES (?,?,?,?)\", (card_no, card_name,card_kind,card_star)) conn.commit() conn.close() #添加卡池和卡牌信息 def insert_pool_card(text_file, db_name): conn = sqlite3.connect(db_name) cursor = conn.cursor() with open(text_file, 'r') as file: lines = file.readlines() for line in lines: pool_name,card_name=line.strip().split(\",\") cursor.execute(\"INSERT INTO poolcard (pool_name, card_name) VALUES (?,?)\", (pool_name,card_name)) conn.commit() conn.close() # 添加抽卡记录 def insert_draw_log(db_name,pool_name,card_name): conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(\"INSERT INTO draw_log (pool_name,card_name) VALUES (?,?)\", (pool_name,card_name)) conn.commit() conn.close() #返回卡牌名 def get_cardname(pool_name, star, db_name): conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(\"SELECT card_name FROM poolcard WHERE pool_name = ?\", (pool_name,)) pool_cards = cursor.fetchall() pool_cards = [card[0] for card in pool_cards] matching_star_cards = [card for card in pool_cards if get_card_star(card, conn) == star] if matching_star_cards: random_card = random.choice(matching_star_cards) else: random_card = None conn.close() return random_card def get_card_star(card_name, conn): cursor = conn.cursor() cursor.execute(\"SELECT card_star FROM card WHERE card_name = ?\", (card_name,)) result = cursor.fetchone() if result: return result[0] else: return None #将数据库的表输出为txt def export_table_to_txt(table_name, db_name, txt_file): conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(f\"SELECT * FROM {table_name}\") table_data = cursor.fetchall() conn.close() #写入文件 with open(txt_file, 'w') as file: for row in table_data: row_str = \"\\t\".join(str(value) for value in row) file.write(row_str + \"\\n\") 在启动器/主文件中引用即可。\n除此之外，还有修改原先的start.py文件的部分内容。 为了使得抽卡记录每次都要存入数据库中，抽卡的单抽和十连函数要略加修改。 具体为\n先添加控件信息的读取 poolname=self.cardpool_Box.currentText()#卡池名 db_name = \"card_database.db\"#db文件名 再添加使用数据库查询的函数，使得每次抽卡获得具体的卡牌名 #得到抽卡结果 cardname=conn2sql.get_cardname(pool_name=poolname,star=star,db_name=db_name) conn2sql.insert_draw_log(db_name,poolname,cardname) #存入抽卡记录的数据库 最后添加抽卡日志的输出 #输出日志文件 table_name=\"draw_log\" txt_file=\"draw_log.txt\" conn2sql.export_table_to_txt(table_name,db_name,txt_file) #抽卡记录表导出为txt 对主文件中的四个抽卡函数(one,one2,ten,ten2)均做类似操作即完成了数据库的连接。\n公告内容可有可无，就是一个信息弹窗。\n注意数据库不要重复创建，开始先判空。\n最后 放在了 \u003cu\u003egithub \u003c/u\u003e上，觉得有用可以Star☆ ，hh 本以为简单搞完的，结果还是搞到了半夜T^T",
    "description": "前言 本贴将之前没有连接数据库的抽卡模拟器全部完善，最终已经放在了Github上",
    "tags": [],
    "title": "【PYQT】赛马娘抽卡模拟器-基于Bwiki的抽卡模拟(下)",
    "uri": "/hugo-theme-relearn/exampleSite/project/uma_drawcard_2/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e ",
    "content": "👋Hi~there 我是 Viogami 一个有服务器开发经验的游戏开发者 – 这是我的博客网站,能像镜子一样反射我的type🤗\n熟悉web后端技术栈，游戏方面也有诸多实践\n📓 My favorite language 👉 \u003ca href=\"https://golang.org\" style=\"color: #00ADD8\"\u003eGolang \u003c/a\u003e\n开发的时候是有各种弯弯绕绕，但是go的输出确实大道至简\nfmt.Println(\"If you can Coding , you must be a Designer!\") 🌐🌐🌐 目前从业互联网后端，每天精进一点设计哲学，向架构发展中。熟悉各种互联网基础设施，并发编程略有实践。 虽然工作内容是天天CURD，但是关注追踪新技术永远乐此不疲。新框架，新组件，预发布，抢先版，喜欢尝试并应用不稳定。\n互联网方面是自己走通过全流程的，前后端然后测试部署等，自然也熟悉python，多用来编写自动化脚本，测试等。AI和机器学习相关方面已止步，底层是无力了解了自有大能为我提供api🙏。\ndocker重度爱好，部署尝试过K8S，但并不熟练。\n🎮🎮🎮 游戏开发方面，unity苦手，除了正向开发，逆向也做了很多工作，不敢说对游戏开发底层有什么理解，但是游戏表现层的实现思路差不多翻来覆去搞的明明白白了。联机方面，对web的数据包传输有相关实践，也做过联机游戏的服务端设计。每一步都是为了自己游戏的铺垫吧。\n主流游戏引擎均有实践，美术音乐靠ai，一点剪辑建模经验，自学日语，双料特工。还是希望有专业的小伙伴联系我，当然，我得先发布我的demo，哈哈\n游戏经历可通过我主页的steam图标点击查看(欢迎好友位)。动作游戏才是游戏之魂！\n崇拜的游戏制作人： Kojima😶‍🌫️ 希望和小岛一样越活越年轻\n👥 友情链接 我的typecho博客站",
    "description": "About this Website",
    "tags": [],
    "title": "About",
    "uri": "/hugo-theme-relearn/exampleSite/_more/about/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship \u003e Midst Ship",
    "content": "Welcome to the legendary 4x4 quarters of Captain Hugo, where navigation charts double as wallpaper and yesterday’s coffee cup might contain tomorrow’s coordinates! The genuine fake window offers stunning views of wherever the captain thinks we are (he’s been known to mistake the Mediterranean for the Caribbean on more than one occasion).\nDespite the creative filing system (read: artistic piles), our beloved captain insists he knows exactly where everything is – including his lucky compass, which has been “temporarily misplaced” for the past three months. The room features state-of-the-art organizational solutions, such as “that chair with all the stuff” and “the corner where important things go.”\nVisitors are kindly requested to not disturb the delicate ecosystem of nautical instruments, half-written logbooks, and at least seven different types of tea sets – all carefully arranged in what the captain calls his “systematic randomness.”",
    "description": "A luxurious 4x4 room, home to our beloved Captain Hugo, with a genuine fake window",
    "tags": [],
    "title": "Captain's Cabin",
    "uri": "/hugo-theme-relearn/exampleSite/ship/midst/captain/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/hugo-theme-relearn/exampleSite/categories/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship \u003e Midst Ship",
    "content": "Welcome to the most entertaining deck of our vessel, where every bunk tells a story and every footlocker holds at least three contraband items that technically violate maritime law. Our distinguished crew members have developed a complex social hierarchy based entirely on who can tell the tallest tale about encounters with legendary sea creatures. Current champion: Bosun McGee, who swears he taught a pod of narwhals to perform synchronized swimming routines.\nThe communal areas are a fascinating study in organized chaos. The mess hall doubles as a debate chamber where heated arguments about the best way to predict weather by reading tea leaves can last for days. The walls are decorated with “accurate” maps drawn by our navigator, complete with illustrations of sea serpents and mysterious islands that somehow move location between each voyage. Our ship’s cat, Admiral Whiskers, holds court from atop the highest shelf, judging everyone’s sea shanty performances with characteristic feline disdain.\nDown in the sleeping quarters, you’ll find an impressive collection of lucky charms, ranging from traditional rabbit’s feet to allegedly enchanted ship’s biscuits that are now too petrified to eat. Each bunk is personalized with trinkets from a hundred ports, though no one can quite explain how we acquired the stuffed dodo bird that watches over the entrance. The night watch maintains a running tally of mysterious lights seen over the water, though there’s strong suspicion that half of these sightings coincide suspiciously with nights when the rum rations were doubled.",
    "description": "Where dreams of mutiny and tales of sea monsters are equally shared",
    "tags": [],
    "title": "Crew Quarters",
    "uri": "/hugo-theme-relearn/exampleSite/ship/midst/crew/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship \u003e Upper Decks",
    "content": "Our dedicated lookout has reported some rather peculiar sightings from his lofty perch. Between his frequent “strategic rest periods” and tea breaks, he’s sworn on his mother’s favorite teacup that he’s witnessed the most extraordinary maritime phenomena ever documented.\nLast week alone, he submitted a detailed report claiming to have spotted a mermaid riding a seahorse while solving a Rubik’s cube, and a group of dolphins wearing top hats performing synchronized swimming routines to classical music.\nRecent notable sightings include:\nA giant squid playing chess with a whale shark Flying fish practicing for their pilot’s license A pirate ghost ship selling timeshares to passing vessels Penguins on vacation riding jet skis A rowing boeat crewed entirely by singing sea cucumbers",
    "description": "Where our lookout pretends to spot land while actually napping",
    "tags": [],
    "title": "Crow's Nest",
    "uri": "/hugo-theme-relearn/exampleSite/ship/upper/nest/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking \u003e 随笔",
    "content": "this is a test file",
    "description": "this is a test file",
    "tags": [],
    "title": "test",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/%E9%9A%8F%E7%AC%94/test/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e The Ship \u003e Upper Decks",
    "content": "Our state-of-the-art navigation system relies heavily on the ancient art of reading cloud shapes and following particularly motivated seagulls. The ship’s wheel, a magnificent piece of mahogany that squeaks exactly like a dolphin’s laugh, is primarily used as an excellent coat hanger during peaceful voyages.\nThe real steering happens through our patented “Serendipitous Navigation System™” – we simply convince the ocean currents they’re flowing in the wrong direction through sophisticated reverse psychology. Our success rate of reaching intended destinations is a proud 12%, though we’ve discovered fourteen previously unknown islands and one mysterious floating coffee shop in the process.",
    "description": "Home to our steering wheel, which may or may not be connected to anything",
    "tags": [],
    "title": "The Helm",
    "uri": "/hugo-theme-relearn/exampleSite/ship/upper/helm/index.html"
  },
  {
    "breadcrumb": "Purple Pulpo \u003e Thinking",
    "content": "test this is a test file",
    "description": "test this is a test file",
    "tags": [],
    "title": "随笔",
    "uri": "/hugo-theme-relearn/exampleSite/thinking/%E9%9A%8F%E7%AC%94/index.html"
  }
]
